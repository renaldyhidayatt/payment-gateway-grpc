// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transfer.sql

package db

import (
	"context"
	"time"
)

const countAllTransfers = `-- name: CountAllTransfers :one
SELECT COUNT(*) FROM transfers WHERE deleted_at IS NULL
`

// Count All Transfers
func (q *Queries) CountAllTransfers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllTransfers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransfersByDate = `-- name: CountTransfersByDate :one
SELECT COUNT(*)
FROM transfers
WHERE deleted_at IS NULL
  AND transfer_time::DATE = $1::DATE
`

// Count Transfers by Date
func (q *Queries) CountTransfersByDate(ctx context.Context, dollar_1 time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransfersByDate, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO
    transfers (
        transfer_from,
        transfer_to,
        transfer_amount,
        transfer_time,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        current_timestamp,
        current_timestamp,
        current_timestamp
    ) RETURNING transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
`

type CreateTransferParams struct {
	TransferFrom   string `json:"transfer_from"`
	TransferTo     string `json:"transfer_to"`
	TransferAmount int32  `json:"transfer_amount"`
}

// Create Transfer
func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, createTransfer, arg.TransferFrom, arg.TransferTo, arg.TransferAmount)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteTransferPermanently = `-- name: DeleteTransferPermanently :exec
DELETE FROM transfers WHERE transfer_id = $1
`

// Delete Transfer Permanently
func (q *Queries) DeleteTransferPermanently(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransferPermanently, transferID)
	return err
}

const getActiveTransfers = `-- name: GetActiveTransfers :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
ORDER BY transfer_time DESC
`

// Get All Active Transfers
func (q *Queries) GetActiveTransfers(ctx context.Context) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransferByID = `-- name: GetTransferByID :one
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

// Get Transfer by ID
func (q *Queries) GetTransferByID(ctx context.Context, transferID int32) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, getTransferByID, transferID)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransfers = `-- name: GetTransfers :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

// Search Transfers with Pagination
func (q *Queries) GetTransfers(ctx context.Context, arg GetTransfersParams) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersByCardNumber = `-- name: GetTransfersByCardNumber :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND (
        transfer_from = $1
        OR transfer_to = $1
    )
ORDER BY transfer_time DESC
`

// Get Transfers by Card Number (Source or Destination)
func (q *Queries) GetTransfersByCardNumber(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersByCardNumber, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersByDestinationCard = `-- name: GetTransfersByDestinationCard :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND transfer_to = $1
ORDER BY transfer_time DESC
`

// Get Transfers by Destination Card
func (q *Queries) GetTransfersByDestinationCard(ctx context.Context, transferTo string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersByDestinationCard, transferTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersBySourceCard = `-- name: GetTransfersBySourceCard :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND transfer_from = $1
ORDER BY transfer_time DESC
`

// Get Transfers by Source Card
func (q *Queries) GetTransfersBySourceCard(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersBySourceCard, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedTransferByID = `-- name: GetTrashedTransferByID :one
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    transfer_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Transfer ID
func (q *Queries) GetTrashedTransferByID(ctx context.Context, transferID int32) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, getTrashedTransferByID, transferID)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedTransfers = `-- name: GetTrashedTransfers :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NOT NULL
ORDER BY transfer_time DESC
`

// Get Trashed Transfers
func (q *Queries) GetTrashedTransfers(ctx context.Context) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreTransfer = `-- name: RestoreTransfer :exec
UPDATE transfers
SET
    deleted_at = NULL
WHERE
    transfer_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Transfer
func (q *Queries) RestoreTransfer(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, restoreTransfer, transferID)
	return err
}

const trashTransfer = `-- name: TrashTransfer :exec
UPDATE transfers
SET
    deleted_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

// Trash Transfer
func (q *Queries) TrashTransfer(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, trashTransfer, transferID)
	return err
}

const updateTransfer = `-- name: UpdateTransfer :exec
UPDATE transfers
SET
    transfer_from = $2,
    transfer_to = $3,
    transfer_amount = $4,
    transfer_time = current_timestamp,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferParams struct {
	TransferID     int32  `json:"transfer_id"`
	TransferFrom   string `json:"transfer_from"`
	TransferTo     string `json:"transfer_to"`
	TransferAmount int32  `json:"transfer_amount"`
}

// Update Transfer
func (q *Queries) UpdateTransfer(ctx context.Context, arg UpdateTransferParams) error {
	_, err := q.db.ExecContext(ctx, updateTransfer,
		arg.TransferID,
		arg.TransferFrom,
		arg.TransferTo,
		arg.TransferAmount,
	)
	return err
}

const updateTransferAmount = `-- name: UpdateTransferAmount :exec
UPDATE transfers
SET
    transfer_amount = $2,
    transfer_time = current_timestamp,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferAmountParams struct {
	TransferID     int32 `json:"transfer_id"`
	TransferAmount int32 `json:"transfer_amount"`
}

// Update Transfer Amount
func (q *Queries) UpdateTransferAmount(ctx context.Context, arg UpdateTransferAmountParams) error {
	_, err := q.db.ExecContext(ctx, updateTransferAmount, arg.TransferID, arg.TransferAmount)
	return err
}
