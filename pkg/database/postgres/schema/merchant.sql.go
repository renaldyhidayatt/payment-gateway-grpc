// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: merchant.sql

package db

import (
	"context"
)

const createMerchant = `-- name: CreateMerchant :one
INSERT INTO
    merchants (
        name,
        api_key,
        user_id,
        status,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        current_timestamp,
        current_timestamp
    ) RETURNING merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at
`

type CreateMerchantParams struct {
	Name   string `json:"name"`
	ApiKey string `json:"api_key"`
	UserID int32  `json:"user_id"`
	Status string `json:"status"`
}

// Create Merchant
func (q *Queries) CreateMerchant(ctx context.Context, arg CreateMerchantParams) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, createMerchant,
		arg.Name,
		arg.ApiKey,
		arg.UserID,
		arg.Status,
	)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteMerchantPermanently = `-- name: DeleteMerchantPermanently :exec
DELETE FROM merchants WHERE merchant_id = $1
`

// Delete Merchant Permanently
func (q *Queries) DeleteMerchantPermanently(ctx context.Context, merchantID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMerchantPermanently, merchantID)
	return err
}

const getActiveMerchants = `-- name: GetActiveMerchants :many
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE
    deleted_at IS NULL
ORDER BY merchant_id
`

// Get All Active Merchants
func (q *Queries) GetActiveMerchants(ctx context.Context) ([]*Merchant, error) {
	rows, err := q.db.QueryContext(ctx, getActiveMerchants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantByApiKey = `-- name: GetMerchantByApiKey :one
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at FROM merchants WHERE api_key = $1 AND deleted_at IS NULL
`

// Get Merchant by API Key
func (q *Queries) GetMerchantByApiKey(ctx context.Context, apiKey string) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getMerchantByApiKey, apiKey)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantByID = `-- name: GetMerchantByID :one
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
`

// Get Merchant by ID
func (q *Queries) GetMerchantByID(ctx context.Context, merchantID int32) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getMerchantByID, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantByName = `-- name: GetMerchantByName :one
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at FROM merchants WHERE name = $1 AND deleted_at IS NULL
`

// Get Merchant by Name
func (q *Queries) GetMerchantByName(ctx context.Context, name string) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getMerchantByName, name)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchants = `-- name: GetMerchants :many
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%' OR api_key ILIKE '%' || $1 || '%' OR status ILIKE '%' || $1 || '%')
ORDER BY merchant_id
LIMIT $2 OFFSET $3
`

type GetMerchantsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

// Search Merchants with Pagination
func (q *Queries) GetMerchants(ctx context.Context, arg GetMerchantsParams) ([]*Merchant, error) {
	rows, err := q.db.QueryContext(ctx, getMerchants, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantsByUserID = `-- name: GetMerchantsByUserID :many
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at FROM merchants WHERE user_id = $1 AND deleted_at IS NULL
`

// Get Merchants by User ID
func (q *Queries) GetMerchantsByUserID(ctx context.Context, userID int32) ([]*Merchant, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedMerchantByID = `-- name: GetTrashedMerchantByID :one
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE
    merchant_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Merchant ID
func (q *Queries) GetTrashedMerchantByID(ctx context.Context, merchantID int32) (*Merchant, error) {
	row := q.db.QueryRowContext(ctx, getTrashedMerchantByID, merchantID)
	var i Merchant
	err := row.Scan(
		&i.MerchantID,
		&i.Name,
		&i.ApiKey,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedMerchants = `-- name: GetTrashedMerchants :many
SELECT merchant_id, name, api_key, user_id, status, created_at, updated_at, deleted_at
FROM merchants
WHERE
    deleted_at IS NOT NULL
ORDER BY merchant_id
`

// Get Trashed Merchants
func (q *Queries) GetTrashedMerchants(ctx context.Context) ([]*Merchant, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedMerchants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.MerchantID,
			&i.Name,
			&i.ApiKey,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreMerchant = `-- name: RestoreMerchant :exec
UPDATE merchants
SET
    deleted_at = NULL
WHERE
    merchant_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Merchant
func (q *Queries) RestoreMerchant(ctx context.Context, merchantID int32) error {
	_, err := q.db.ExecContext(ctx, restoreMerchant, merchantID)
	return err
}

const trashMerchant = `-- name: TrashMerchant :exec
UPDATE merchants
SET
    deleted_at = current_timestamp
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
`

// Trash Merchant
func (q *Queries) TrashMerchant(ctx context.Context, merchantID int32) error {
	_, err := q.db.ExecContext(ctx, trashMerchant, merchantID)
	return err
}

const updateMerchant = `-- name: UpdateMerchant :exec
UPDATE merchants
SET
    name = $2,
    user_id = $3,
    status = $4,
    updated_at = current_timestamp
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
`

type UpdateMerchantParams struct {
	MerchantID int32  `json:"merchant_id"`
	Name       string `json:"name"`
	UserID     int32  `json:"user_id"`
	Status     string `json:"status"`
}

// Update Merchant
func (q *Queries) UpdateMerchant(ctx context.Context, arg UpdateMerchantParams) error {
	_, err := q.db.ExecContext(ctx, updateMerchant,
		arg.MerchantID,
		arg.Name,
		arg.UserID,
		arg.Status,
	)
	return err
}
