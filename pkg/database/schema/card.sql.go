// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: card.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createCard = `-- name: CreateCard :one
INSERT INTO
    cards (
        user_id,
        card_number,
        card_type,
        expire_date,
        cvv,
        card_provider,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        current_timestamp,
        current_timestamp
    ) RETURNING card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at
`

type CreateCardParams struct {
	UserID       int32     `json:"user_id"`
	CardNumber   string    `json:"card_number"`
	CardType     string    `json:"card_type"`
	ExpireDate   time.Time `json:"expire_date"`
	Cvv          string    `json:"cvv"`
	CardProvider string    `json:"card_provider"`
}

// Create Card
func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (*Card, error) {
	row := q.db.QueryRowContext(ctx, createCard,
		arg.UserID,
		arg.CardNumber,
		arg.CardType,
		arg.ExpireDate,
		arg.Cvv,
		arg.CardProvider,
	)
	var i Card
	err := row.Scan(
		&i.CardID,
		&i.UserID,
		&i.CardNumber,
		&i.CardType,
		&i.ExpireDate,
		&i.Cvv,
		&i.CardProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentCards = `-- name: DeleteAllPermanentCards :exec
DELETE FROM cards
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Cards Permanently
func (q *Queries) DeleteAllPermanentCards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentCards)
	return err
}

const deleteCardPermanently = `-- name: DeleteCardPermanently :exec
DELETE FROM cards WHERE card_id = $1 AND deleted_at IS NOT NULL
`

// Delete Card Permanently
func (q *Queries) DeleteCardPermanently(ctx context.Context, cardID int32) error {
	_, err := q.db.ExecContext(ctx, deleteCardPermanently, cardID)
	return err
}

const getActiveCardsWithCount = `-- name: GetActiveCardsWithCount :many
SELECT
    card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cards
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%' OR card_type ILIKE '%' || $1 || '%' OR card_provider ILIKE '%' || $1 || '%')
ORDER BY card_id
LIMIT $2 OFFSET $3
`

type GetActiveCardsWithCountParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveCardsWithCountRow struct {
	CardID       int32        `json:"card_id"`
	UserID       int32        `json:"user_id"`
	CardNumber   string       `json:"card_number"`
	CardType     string       `json:"card_type"`
	ExpireDate   time.Time    `json:"expire_date"`
	Cvv          string       `json:"cvv"`
	CardProvider string       `json:"card_provider"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	TotalCount   int64        `json:"total_count"`
}

func (q *Queries) GetActiveCardsWithCount(ctx context.Context, arg GetActiveCardsWithCountParams) ([]*GetActiveCardsWithCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveCardsWithCount, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveCardsWithCountRow
	for rows.Next() {
		var i GetActiveCardsWithCountRow
		if err := rows.Scan(
			&i.CardID,
			&i.UserID,
			&i.CardNumber,
			&i.CardType,
			&i.ExpireDate,
			&i.Cvv,
			&i.CardProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBalances = `-- name: GetAllBalances :many
SELECT
    c.card_number,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
JOIN
    cards c ON s.card_number = c.card_number
WHERE
    s.deleted_at IS NULL AND c.deleted_at IS NULL
GROUP BY
    c.card_number
ORDER BY
    total_balance DESC
`

type GetAllBalancesRow struct {
	CardNumber   string `json:"card_number"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetAllBalances(ctx context.Context) ([]*GetAllBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllBalancesRow
	for rows.Next() {
		var i GetAllBalancesRow
		if err := rows.Scan(&i.CardNumber, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCardByCardNumber = `-- name: GetCardByCardNumber :one
SELECT card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at FROM cards WHERE card_number = $1 AND deleted_at IS NULL
`

// Get Card by Card Number
func (q *Queries) GetCardByCardNumber(ctx context.Context, cardNumber string) (*Card, error) {
	row := q.db.QueryRowContext(ctx, getCardByCardNumber, cardNumber)
	var i Card
	err := row.Scan(
		&i.CardID,
		&i.UserID,
		&i.CardNumber,
		&i.CardType,
		&i.ExpireDate,
		&i.Cvv,
		&i.CardProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getCardByID = `-- name: GetCardByID :one
SELECT card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at FROM cards WHERE card_id = $1 AND deleted_at IS NULL
`

// Get Card by ID
func (q *Queries) GetCardByID(ctx context.Context, cardID int32) (*Card, error) {
	row := q.db.QueryRowContext(ctx, getCardByID, cardID)
	var i Card
	err := row.Scan(
		&i.CardID,
		&i.UserID,
		&i.CardNumber,
		&i.CardType,
		&i.ExpireDate,
		&i.Cvv,
		&i.CardProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getCardByUserID = `-- name: GetCardByUserID :one
SELECT card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at
FROM cards
WHERE
    user_id = $1
    AND deleted_at IS NULL
LIMIT 1
`

// Get a single Card by User ID
func (q *Queries) GetCardByUserID(ctx context.Context, userID int32) (*Card, error) {
	row := q.db.QueryRowContext(ctx, getCardByUserID, userID)
	var i Card
	err := row.Scan(
		&i.CardID,
		&i.UserID,
		&i.CardNumber,
		&i.CardType,
		&i.ExpireDate,
		&i.Cvv,
		&i.CardProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getCards = `-- name: GetCards :many
SELECT
    card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cards
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%' OR card_type ILIKE '%' || $1 || '%' OR card_provider ILIKE '%' || $1 || '%')
ORDER BY card_id
LIMIT $2 OFFSET $3
`

type GetCardsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetCardsRow struct {
	CardID       int32        `json:"card_id"`
	UserID       int32        `json:"user_id"`
	CardNumber   string       `json:"card_number"`
	CardType     string       `json:"card_type"`
	ExpireDate   time.Time    `json:"expire_date"`
	Cvv          string       `json:"cvv"`
	CardProvider string       `json:"card_provider"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	TotalCount   int64        `json:"total_count"`
}

// Search Cards with Pagination and Total Count
func (q *Queries) GetCards(ctx context.Context, arg GetCardsParams) ([]*GetCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCards, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCardsRow
	for rows.Next() {
		var i GetCardsRow
		if err := rows.Scan(
			&i.CardID,
			&i.UserID,
			&i.CardNumber,
			&i.CardType,
			&i.ExpireDate,
			&i.Cvv,
			&i.CardProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyBalances = `-- name: GetMonthlyBalances :many
SELECT
    TO_CHAR(s.created_at, 'Mon') AS month,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
JOIN
    cards c ON s.card_number = c.card_number
WHERE
    s.deleted_at IS NULL AND c.deleted_at IS NULL
    AND EXTRACT(YEAR FROM s.created_at) = $1
GROUP BY
    TO_CHAR(s.created_at, 'Mon'), EXTRACT(MONTH FROM s.created_at)
ORDER BY
    EXTRACT(MONTH FROM s.created_at)
`

type GetMonthlyBalancesRow struct {
	Month        string `json:"month"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetMonthlyBalances(ctx context.Context, createdAt sql.NullTime) ([]*GetMonthlyBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyBalances, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyBalancesRow
	for rows.Next() {
		var i GetMonthlyBalancesRow
		if err := rows.Scan(&i.Month, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyBalancesByCardNumber = `-- name: GetMonthlyBalancesByCardNumber :many
SELECT
    TO_CHAR(s.created_at, 'Mon') AS month,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
JOIN
    cards c ON s.card_number = c.card_number
WHERE
    s.deleted_at IS NULL
    AND c.deleted_at IS NULL
    AND s.card_number = $1
    AND EXTRACT(YEAR FROM s.created_at) = $2
GROUP BY
    TO_CHAR(s.created_at, 'Mon'),
    EXTRACT(MONTH FROM s.created_at)
ORDER BY
    EXTRACT(MONTH FROM s.created_at)
`

type GetMonthlyBalancesByCardNumberParams struct {
	CardNumber string       `json:"card_number"`
	CreatedAt  sql.NullTime `json:"created_at"`
}

type GetMonthlyBalancesByCardNumberRow struct {
	Month        string `json:"month"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetMonthlyBalancesByCardNumber(ctx context.Context, arg GetMonthlyBalancesByCardNumberParams) ([]*GetMonthlyBalancesByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyBalancesByCardNumber, arg.CardNumber, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyBalancesByCardNumberRow
	for rows.Next() {
		var i GetMonthlyBalancesByCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedCardByID = `-- name: GetTrashedCardByID :one
SELECT card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at FROM cards WHERE card_id = $1 AND deleted_at IS NOT NULL
`

// Get Trashed By Card ID
func (q *Queries) GetTrashedCardByID(ctx context.Context, cardID int32) (*Card, error) {
	row := q.db.QueryRowContext(ctx, getTrashedCardByID, cardID)
	var i Card
	err := row.Scan(
		&i.CardID,
		&i.UserID,
		&i.CardNumber,
		&i.CardType,
		&i.ExpireDate,
		&i.Cvv,
		&i.CardProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedCardsWithCount = `-- name: GetTrashedCardsWithCount :many
SELECT
    card_id, user_id, card_number, card_type, expire_date, cvv, card_provider, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM cards
WHERE deleted_at IS NOT NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%' OR card_type ILIKE '%' || $1 || '%' OR card_provider ILIKE '%' || $1 || '%')
ORDER BY card_id
LIMIT $2 OFFSET $3
`

type GetTrashedCardsWithCountParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedCardsWithCountRow struct {
	CardID       int32        `json:"card_id"`
	UserID       int32        `json:"user_id"`
	CardNumber   string       `json:"card_number"`
	CardType     string       `json:"card_type"`
	ExpireDate   time.Time    `json:"expire_date"`
	Cvv          string       `json:"cvv"`
	CardProvider string       `json:"card_provider"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	TotalCount   int64        `json:"total_count"`
}

func (q *Queries) GetTrashedCardsWithCount(ctx context.Context, arg GetTrashedCardsWithCountParams) ([]*GetTrashedCardsWithCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedCardsWithCount, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedCardsWithCountRow
	for rows.Next() {
		var i GetTrashedCardsWithCountRow
		if err := rows.Scan(
			&i.CardID,
			&i.UserID,
			&i.CardNumber,
			&i.CardType,
			&i.ExpireDate,
			&i.Cvv,
			&i.CardProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyBalances = `-- name: GetYearlyBalances :many
SELECT
    EXTRACT(YEAR FROM s.created_at) AS year,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
JOIN
    cards c ON s.card_number = c.card_number
WHERE
    s.deleted_at IS NULL AND c.deleted_at IS NULL
GROUP BY
    EXTRACT(YEAR FROM s.created_at)
ORDER BY
    year
`

type GetYearlyBalancesRow struct {
	Year         string `json:"year"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetYearlyBalances(ctx context.Context) ([]*GetYearlyBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyBalancesRow
	for rows.Next() {
		var i GetYearlyBalancesRow
		if err := rows.Scan(&i.Year, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyBalancesByCardNUmber = `-- name: GetYearlyBalancesByCardNUmber :many
SELECT
    EXTRACT(YEAR FROM s.created_at) AS year,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
JOIN
    cards c ON s.card_number = c.card_number
WHERE
    s.deleted_at IS NULL
    AND c.deleted_at IS NULL
    AND s.card_number = $1
GROUP BY
    EXTRACT(YEAR FROM s.created_at)
ORDER BY
    year
`

type GetYearlyBalancesByCardNUmberRow struct {
	Year         string `json:"year"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetYearlyBalancesByCardNUmber(ctx context.Context, cardNumber string) ([]*GetYearlyBalancesByCardNUmberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyBalancesByCardNUmber, cardNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyBalancesByCardNUmberRow
	for rows.Next() {
		var i GetYearlyBalancesByCardNUmberRow
		if err := rows.Scan(&i.Year, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllCards = `-- name: RestoreAllCards :exec
UPDATE cards
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Cards
func (q *Queries) RestoreAllCards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllCards)
	return err
}

const restoreCard = `-- name: RestoreCard :exec
UPDATE cards
SET
    deleted_at = NULL
WHERE
    card_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Card
func (q *Queries) RestoreCard(ctx context.Context, cardID int32) error {
	_, err := q.db.ExecContext(ctx, restoreCard, cardID)
	return err
}

const trashCard = `-- name: TrashCard :exec
UPDATE cards
SET
    deleted_at = current_timestamp
WHERE
    card_id = $1
    AND deleted_at IS NULL
`

// Trash Card
func (q *Queries) TrashCard(ctx context.Context, cardID int32) error {
	_, err := q.db.ExecContext(ctx, trashCard, cardID)
	return err
}

const updateCard = `-- name: UpdateCard :exec
UPDATE cards
SET
    card_type = $2,
    expire_date = $3,
    cvv = $4,
    card_provider = $5,
    updated_at = current_timestamp
WHERE
    card_id = $1
    AND deleted_at IS NULL
`

type UpdateCardParams struct {
	CardID       int32     `json:"card_id"`
	CardType     string    `json:"card_type"`
	ExpireDate   time.Time `json:"expire_date"`
	Cvv          string    `json:"cvv"`
	CardProvider string    `json:"card_provider"`
}

// Update Card
func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) error {
	_, err := q.db.ExecContext(ctx, updateCard,
		arg.CardID,
		arg.CardType,
		arg.ExpireDate,
		arg.Cvv,
		arg.CardProvider,
	)
	return err
}
