// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: withdraw.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countActiveWithdrawsByDate = `-- name: CountActiveWithdrawsByDate :one
SELECT COUNT(*)
FROM withdraws
WHERE deleted_at IS NULL AND withdraw_time::DATE = $1
`

// Count Active Withdraws by Date
func (q *Queries) CountActiveWithdrawsByDate(ctx context.Context, withdrawTime time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveWithdrawsByDate, withdrawTime)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllWithdraws = `-- name: CountAllWithdraws :one
SELECT COUNT(*)
FROM withdraws
WHERE deleted_at IS NULL
`

func (q *Queries) CountAllWithdraws(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllWithdraws)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWithdraws = `-- name: CountWithdraws :one
SELECT COUNT(*)
FROM withdraws
WHERE deleted_at IS NULL
    AND ($1::TEXT IS NULL OR
        card_number ILIKE '%' || $1 || '%' OR
        CAST(withdraw_amount AS TEXT) ILIKE '%' || $1 || '%' OR
        CAST(withdraw_time AS TEXT) ILIKE '%' || $1 || '%')
`

func (q *Queries) CountWithdraws(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWithdraws, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWithdraw = `-- name: CreateWithdraw :one
INSERT INTO
    withdraws (
        card_number,
        withdraw_amount,
        withdraw_time,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        current_timestamp,
        current_timestamp
    ) RETURNING withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at
`

type CreateWithdrawParams struct {
	CardNumber     string    `json:"card_number"`
	WithdrawAmount int32     `json:"withdraw_amount"`
	WithdrawTime   time.Time `json:"withdraw_time"`
}

// Create Withdraw
func (q *Queries) CreateWithdraw(ctx context.Context, arg CreateWithdrawParams) (*Withdraw, error) {
	row := q.db.QueryRowContext(ctx, createWithdraw, arg.CardNumber, arg.WithdrawAmount, arg.WithdrawTime)
	var i Withdraw
	err := row.Scan(
		&i.WithdrawID,
		&i.CardNumber,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentWithdraws = `-- name: DeleteAllPermanentWithdraws :exec
DELETE FROM withdraws
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Withdraws Permanently
func (q *Queries) DeleteAllPermanentWithdraws(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentWithdraws)
	return err
}

const deleteWithdrawPermanently = `-- name: DeleteWithdrawPermanently :exec
DELETE FROM withdraws WHERE withdraw_id = $1 AND deleted_at IS NOT NULL
`

// Delete Withdraw Permanently
func (q *Queries) DeleteWithdrawPermanently(ctx context.Context, withdrawID int32) error {
	_, err := q.db.ExecContext(ctx, deleteWithdrawPermanently, withdrawID)
	return err
}

const findAllWithdrawsByCardNumber = `-- name: FindAllWithdrawsByCardNumber :many
SELECT
    w.withdraw_id,
    w.card_number,
    w.withdraw_amount,
    w.withdraw_time,
    w.created_at,
    w.updated_at,
    w.deleted_at
FROM
    withdraws w
WHERE
    w.card_number = $1
    AND w.deleted_at IS NULL
ORDER BY
    w.withdraw_time DESC
`

func (q *Queries) FindAllWithdrawsByCardNumber(ctx context.Context, cardNumber string) ([]*Withdraw, error) {
	rows, err := q.db.QueryContext(ctx, findAllWithdrawsByCardNumber, cardNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Withdraw
	for rows.Next() {
		var i Withdraw
		if err := rows.Scan(
			&i.WithdrawID,
			&i.CardNumber,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveWithdraws = `-- name: GetActiveWithdraws :many
SELECT
    withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    withdraws
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY
    withdraw_time DESC
LIMIT $2 OFFSET $3
`

type GetActiveWithdrawsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveWithdrawsRow struct {
	WithdrawID     int32        `json:"withdraw_id"`
	CardNumber     string       `json:"card_number"`
	WithdrawAmount int32        `json:"withdraw_amount"`
	WithdrawTime   time.Time    `json:"withdraw_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Get Active Withdraws with Search, Pagination, and Total Count
func (q *Queries) GetActiveWithdraws(ctx context.Context, arg GetActiveWithdrawsParams) ([]*GetActiveWithdrawsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveWithdraws, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveWithdrawsRow
	for rows.Next() {
		var i GetActiveWithdrawsRow
		if err := rows.Scan(
			&i.WithdrawID,
			&i.CardNumber,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyWithdraws = `-- name: GetMonthlyWithdraws :many
SELECT
    TO_CHAR(w.withdraw_time, 'Mon') AS month,
    SUM(w.withdraw_amount) AS total_withdraw_amount
FROM
    withdraws w
WHERE
    w.deleted_at IS NULL
    AND EXTRACT(YEAR FROM w.withdraw_time) = $1
GROUP BY
    TO_CHAR(w.withdraw_time, 'Mon'),
    EXTRACT(MONTH FROM w.withdraw_time)
ORDER BY
    EXTRACT(MONTH FROM w.withdraw_time)
`

type GetMonthlyWithdrawsRow struct {
	Month               string `json:"month"`
	TotalWithdrawAmount int64  `json:"total_withdraw_amount"`
}

func (q *Queries) GetMonthlyWithdraws(ctx context.Context, withdrawTime time.Time) ([]*GetMonthlyWithdrawsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyWithdraws, withdrawTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyWithdrawsRow
	for rows.Next() {
		var i GetMonthlyWithdrawsRow
		if err := rows.Scan(&i.Month, &i.TotalWithdrawAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyWithdrawsByCardNumber = `-- name: GetMonthlyWithdrawsByCardNumber :many
SELECT
    TO_CHAR(w.withdraw_time, 'Mon') AS month,
    SUM(w.withdraw_amount) AS total_withdraw_amount
FROM
    withdraws w
WHERE
    w.card_number = $1
    AND w.deleted_at IS NULL
    AND EXTRACT(YEAR FROM w.withdraw_time) = $2
GROUP BY
    TO_CHAR(w.withdraw_time, 'Mon'),
    EXTRACT(MONTH FROM w.withdraw_time)
ORDER BY
    EXTRACT(MONTH FROM w.withdraw_time)
`

type GetMonthlyWithdrawsByCardNumberParams struct {
	CardNumber   string    `json:"card_number"`
	WithdrawTime time.Time `json:"withdraw_time"`
}

type GetMonthlyWithdrawsByCardNumberRow struct {
	Month               string `json:"month"`
	TotalWithdrawAmount int64  `json:"total_withdraw_amount"`
}

func (q *Queries) GetMonthlyWithdrawsByCardNumber(ctx context.Context, arg GetMonthlyWithdrawsByCardNumberParams) ([]*GetMonthlyWithdrawsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyWithdrawsByCardNumber, arg.CardNumber, arg.WithdrawTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyWithdrawsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyWithdrawsByCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalWithdrawAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedWithdrawByID = `-- name: GetTrashedWithdrawByID :one
SELECT withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at
FROM withdraws
WHERE
    withdraw_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Withdraw ID
func (q *Queries) GetTrashedWithdrawByID(ctx context.Context, withdrawID int32) (*Withdraw, error) {
	row := q.db.QueryRowContext(ctx, getTrashedWithdrawByID, withdrawID)
	var i Withdraw
	err := row.Scan(
		&i.WithdrawID,
		&i.CardNumber,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedWithdraws = `-- name: GetTrashedWithdraws :many
SELECT
    withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    withdraws
WHERE
    deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY
    withdraw_time DESC
LIMIT $2 OFFSET $3
`

type GetTrashedWithdrawsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedWithdrawsRow struct {
	WithdrawID     int32        `json:"withdraw_id"`
	CardNumber     string       `json:"card_number"`
	WithdrawAmount int32        `json:"withdraw_amount"`
	WithdrawTime   time.Time    `json:"withdraw_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Get Trashed Withdraws with Search, Pagination, and Total Count
func (q *Queries) GetTrashedWithdraws(ctx context.Context, arg GetTrashedWithdrawsParams) ([]*GetTrashedWithdrawsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedWithdraws, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedWithdrawsRow
	for rows.Next() {
		var i GetTrashedWithdrawsRow
		if err := rows.Scan(
			&i.WithdrawID,
			&i.CardNumber,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWithdrawByID = `-- name: GetWithdrawByID :one
SELECT withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at
FROM withdraws
WHERE
    withdraw_id = $1
    AND deleted_at IS NULL
`

// Get Withdraw by ID
func (q *Queries) GetWithdrawByID(ctx context.Context, withdrawID int32) (*Withdraw, error) {
	row := q.db.QueryRowContext(ctx, getWithdrawByID, withdrawID)
	var i Withdraw
	err := row.Scan(
		&i.WithdrawID,
		&i.CardNumber,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getWithdraws = `-- name: GetWithdraws :many
SELECT
    withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    withdraws
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY
    withdraw_time DESC
LIMIT $2 OFFSET $3
`

type GetWithdrawsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetWithdrawsRow struct {
	WithdrawID     int32        `json:"withdraw_id"`
	CardNumber     string       `json:"card_number"`
	WithdrawAmount int32        `json:"withdraw_amount"`
	WithdrawTime   time.Time    `json:"withdraw_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Search Withdraws with Pagination
func (q *Queries) GetWithdraws(ctx context.Context, arg GetWithdrawsParams) ([]*GetWithdrawsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWithdraws, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWithdrawsRow
	for rows.Next() {
		var i GetWithdrawsRow
		if err := rows.Scan(
			&i.WithdrawID,
			&i.CardNumber,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyWithdraws = `-- name: GetYearlyWithdraws :many
SELECT
    EXTRACT(YEAR FROM w.withdraw_time) AS year,
    SUM(w.withdraw_amount) AS total_withdraw_amount
FROM
    withdraws w
WHERE
    w.deleted_at IS NULL
GROUP BY
    EXTRACT(YEAR FROM w.withdraw_time)
ORDER BY
    year
`

type GetYearlyWithdrawsRow struct {
	Year                string `json:"year"`
	TotalWithdrawAmount int64  `json:"total_withdraw_amount"`
}

func (q *Queries) GetYearlyWithdraws(ctx context.Context) ([]*GetYearlyWithdrawsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyWithdraws)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyWithdrawsRow
	for rows.Next() {
		var i GetYearlyWithdrawsRow
		if err := rows.Scan(&i.Year, &i.TotalWithdrawAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyWithdrawsByCardNumber = `-- name: GetYearlyWithdrawsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM w.withdraw_time) AS year,
    SUM(w.withdraw_amount) AS total_withdraw_amount
FROM
    withdraws w
WHERE
    w.deleted_at IS NULL
    AND w.card_number = $1
GROUP BY
    EXTRACT(YEAR FROM w.withdraw_time)
ORDER BY
    year
`

type GetYearlyWithdrawsByCardNumberRow struct {
	Year                string `json:"year"`
	TotalWithdrawAmount int64  `json:"total_withdraw_amount"`
}

func (q *Queries) GetYearlyWithdrawsByCardNumber(ctx context.Context, cardNumber string) ([]*GetYearlyWithdrawsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyWithdrawsByCardNumber, cardNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyWithdrawsByCardNumberRow
	for rows.Next() {
		var i GetYearlyWithdrawsByCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalWithdrawAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllWithdraws = `-- name: RestoreAllWithdraws :exec
UPDATE withdraws
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Withdraws
func (q *Queries) RestoreAllWithdraws(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllWithdraws)
	return err
}

const restoreWithdraw = `-- name: RestoreWithdraw :exec
UPDATE withdraws
SET
    deleted_at = NULL
WHERE
    withdraw_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Withdraw (Undelete)
func (q *Queries) RestoreWithdraw(ctx context.Context, withdrawID int32) error {
	_, err := q.db.ExecContext(ctx, restoreWithdraw, withdrawID)
	return err
}

const searchWithdrawByCardNumber = `-- name: SearchWithdrawByCardNumber :many
SELECT withdraw_id, card_number, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at
FROM withdraws
WHERE
    deleted_at IS NULL
    AND card_number ILIKE '%' || $1 || '%'
ORDER BY withdraw_time DESC
`

// Search Withdraw by Card Number
func (q *Queries) SearchWithdrawByCardNumber(ctx context.Context, dollar_1 sql.NullString) ([]*Withdraw, error) {
	rows, err := q.db.QueryContext(ctx, searchWithdrawByCardNumber, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Withdraw
	for rows.Next() {
		var i Withdraw
		if err := rows.Scan(
			&i.WithdrawID,
			&i.CardNumber,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trashWithdraw = `-- name: TrashWithdraw :exec
UPDATE withdraws
SET
    deleted_at = current_timestamp
WHERE
    withdraw_id = $1
    AND deleted_at IS NULL
`

// Trash Withdraw (Soft Delete)
func (q *Queries) TrashWithdraw(ctx context.Context, withdrawID int32) error {
	_, err := q.db.ExecContext(ctx, trashWithdraw, withdrawID)
	return err
}

const updateWithdraw = `-- name: UpdateWithdraw :exec
UPDATE withdraws
SET
    card_number = $2,
    withdraw_amount = $3,
    withdraw_time = $4,
    updated_at = current_timestamp
WHERE
    withdraw_id = $1
    AND deleted_at IS NULL
`

type UpdateWithdrawParams struct {
	WithdrawID     int32     `json:"withdraw_id"`
	CardNumber     string    `json:"card_number"`
	WithdrawAmount int32     `json:"withdraw_amount"`
	WithdrawTime   time.Time `json:"withdraw_time"`
}

// Update Withdraw
func (q *Queries) UpdateWithdraw(ctx context.Context, arg UpdateWithdrawParams) error {
	_, err := q.db.ExecContext(ctx, updateWithdraw,
		arg.WithdrawID,
		arg.CardNumber,
		arg.WithdrawAmount,
		arg.WithdrawTime,
	)
	return err
}
