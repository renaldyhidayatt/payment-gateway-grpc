// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: saldo.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createSaldo = `-- name: CreateSaldo :one
INSERT INTO
    saldos (
        card_number,
        total_balance,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        current_timestamp,
        current_timestamp
    ) RETURNING saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at
`

type CreateSaldoParams struct {
	CardNumber   string `json:"card_number"`
	TotalBalance int32  `json:"total_balance"`
}

// Create Saldo
func (q *Queries) CreateSaldo(ctx context.Context, arg CreateSaldoParams) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, createSaldo, arg.CardNumber, arg.TotalBalance)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentSaldos = `-- name: DeleteAllPermanentSaldos :exec
DELETE FROM saldos
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Saldos Permanently
func (q *Queries) DeleteAllPermanentSaldos(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentSaldos)
	return err
}

const deleteSaldoPermanently = `-- name: DeleteSaldoPermanently :exec
DELETE FROM saldos WHERE saldo_id = $1 AND deleted_at IS NOT NULL
`

// Delete Saldo Permanently
func (q *Queries) DeleteSaldoPermanently(ctx context.Context, saldoID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSaldoPermanently, saldoID)
	return err
}

const getActiveSaldos = `-- name: GetActiveSaldos :many
SELECT
    saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM saldos
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY saldo_id
LIMIT $2 OFFSET $3
`

type GetActiveSaldosParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveSaldosRow struct {
	SaldoID        int32         `json:"saldo_id"`
	CardNumber     string        `json:"card_number"`
	TotalBalance   int32         `json:"total_balance"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	UpdatedAt      sql.NullTime  `json:"updated_at"`
	DeletedAt      sql.NullTime  `json:"deleted_at"`
	TotalCount     int64         `json:"total_count"`
}

// Get All Active Saldos with Pagination, Search, and Total Count
func (q *Queries) GetActiveSaldos(ctx context.Context, arg GetActiveSaldosParams) ([]*GetActiveSaldosRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSaldos, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveSaldosRow
	for rows.Next() {
		var i GetActiveSaldosRow
		if err := rows.Scan(
			&i.SaldoID,
			&i.CardNumber,
			&i.TotalBalance,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlySaldoBalances = `-- name: GetMonthlySaldoBalances :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(s.total_balance), 0)::int AS total_balance
FROM
    months m
LEFT JOIN
    saldos s ON EXTRACT(MONTH FROM s.created_at) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM s.created_at) = EXTRACT(YEAR FROM m.month)
    AND s.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlySaldoBalancesRow struct {
	Month        string `json:"month"`
	TotalBalance int32  `json:"total_balance"`
}

func (q *Queries) GetMonthlySaldoBalances(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlySaldoBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlySaldoBalances, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlySaldoBalancesRow
	for rows.Next() {
		var i GetMonthlySaldoBalancesRow
		if err := rows.Scan(&i.Month, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalSaldoBalance = `-- name: GetMonthlyTotalSaldoBalance :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM s.created_at)::integer AS year,
        EXTRACT(MONTH FROM s.created_at)::integer AS month,
        SUM(s.total_balance) AS total_balance
    FROM
        saldos s
    WHERE
        s.deleted_at IS NULL
        AND (
            (s.created_at >= $1::timestamp AND s.created_at <= $2::timestamp)
            OR (s.created_at >= $3::timestamp AND s.created_at <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM s.created_at),
        EXTRACT(MONTH FROM s.created_at)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_balance
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_balance
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_balance
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_balance FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthlyTotalSaldoBalanceParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthlyTotalSaldoBalanceRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetMonthlyTotalSaldoBalance(ctx context.Context, arg GetMonthlyTotalSaldoBalanceParams) ([]*GetMonthlyTotalSaldoBalanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalSaldoBalance,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalSaldoBalanceRow
	for rows.Next() {
		var i GetMonthlyTotalSaldoBalanceRow
		if err := rows.Scan(&i.Year, &i.Month, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSaldoByCardNumber = `-- name: GetSaldoByCardNumber :one
SELECT saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at FROM saldos WHERE card_number = $1 AND deleted_at IS NULL
`

// Get Saldo by Card Number
func (q *Queries) GetSaldoByCardNumber(ctx context.Context, cardNumber string) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, getSaldoByCardNumber, cardNumber)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSaldoByID = `-- name: GetSaldoByID :one
SELECT saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at FROM saldos WHERE saldo_id = $1 AND deleted_at IS NULL
`

// Get Saldo by ID
func (q *Queries) GetSaldoByID(ctx context.Context, saldoID int32) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, getSaldoByID, saldoID)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSaldos = `-- name: GetSaldos :many
SELECT
    saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM saldos
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY saldo_id
LIMIT $2 OFFSET $3
`

type GetSaldosParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetSaldosRow struct {
	SaldoID        int32         `json:"saldo_id"`
	CardNumber     string        `json:"card_number"`
	TotalBalance   int32         `json:"total_balance"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	UpdatedAt      sql.NullTime  `json:"updated_at"`
	DeletedAt      sql.NullTime  `json:"deleted_at"`
	TotalCount     int64         `json:"total_count"`
}

// Search Saldos with Pagination and Total Count
func (q *Queries) GetSaldos(ctx context.Context, arg GetSaldosParams) ([]*GetSaldosRow, error) {
	rows, err := q.db.QueryContext(ctx, getSaldos, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSaldosRow
	for rows.Next() {
		var i GetSaldosRow
		if err := rows.Scan(
			&i.SaldoID,
			&i.CardNumber,
			&i.TotalBalance,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedSaldoByID = `-- name: GetTrashedSaldoByID :one
SELECT saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at FROM saldos WHERE saldo_id = $1 AND deleted_at IS NOT NULL
`

// Get Trashed By Saldo ID
func (q *Queries) GetTrashedSaldoByID(ctx context.Context, saldoID int32) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, getTrashedSaldoByID, saldoID)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedSaldos = `-- name: GetTrashedSaldos :many
SELECT
    saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM saldos
WHERE deleted_at IS NOT NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY saldo_id
LIMIT $2 OFFSET $3
`

type GetTrashedSaldosParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedSaldosRow struct {
	SaldoID        int32         `json:"saldo_id"`
	CardNumber     string        `json:"card_number"`
	TotalBalance   int32         `json:"total_balance"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	UpdatedAt      sql.NullTime  `json:"updated_at"`
	DeletedAt      sql.NullTime  `json:"deleted_at"`
	TotalCount     int64         `json:"total_count"`
}

// Get Trashed Saldos with Pagination, Search, and Total Count
func (q *Queries) GetTrashedSaldos(ctx context.Context, arg GetTrashedSaldosParams) ([]*GetTrashedSaldosRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedSaldos, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedSaldosRow
	for rows.Next() {
		var i GetTrashedSaldosRow
		if err := rows.Scan(
			&i.SaldoID,
			&i.CardNumber,
			&i.TotalBalance,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlySaldoBalances = `-- name: GetYearlySaldoBalances :many
WITH last_five_years AS (
    SELECT
        EXTRACT(YEAR FROM s.created_at) AS year,
        SUM(s.total_balance) AS total_balance
    FROM
        saldos s
    WHERE
        s.deleted_at IS NULL
        AND EXTRACT(YEAR FROM s.created_at) >= $1 - 4
        AND EXTRACT(YEAR FROM s.created_at) <= $1
    GROUP BY
        EXTRACT(YEAR FROM s.created_at)
)
SELECT
    year,
    total_balance
FROM
    last_five_years
ORDER BY
    year
`

type GetYearlySaldoBalancesRow struct {
	Year         string `json:"year"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetYearlySaldoBalances(ctx context.Context, dollar_1 interface{}) ([]*GetYearlySaldoBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlySaldoBalances, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlySaldoBalancesRow
	for rows.Next() {
		var i GetYearlySaldoBalancesRow
		if err := rows.Scan(&i.Year, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalSaldoBalances = `-- name: GetYearlyTotalSaldoBalances :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM s.created_at)::integer AS year,
        COALESCE(SUM(s.total_balance), 0)::integer AS total_balance
    FROM
        saldos s
    WHERE
        s.deleted_at IS NULL
        AND (
            EXTRACT(YEAR FROM s.created_at) = $1::integer
            OR EXTRACT(YEAR FROM s.created_at) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM s.created_at)
), formatted_data AS (
    SELECT
        year::text,
        total_balance::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_balance
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_balance
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_balance FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTotalSaldoBalancesRow struct {
	Year         string `json:"year"`
	TotalBalance int32  `json:"total_balance"`
}

func (q *Queries) GetYearlyTotalSaldoBalances(ctx context.Context, dollar_1 int32) ([]*GetYearlyTotalSaldoBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalSaldoBalances, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalSaldoBalancesRow
	for rows.Next() {
		var i GetYearlyTotalSaldoBalancesRow
		if err := rows.Scan(&i.Year, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllSaldos = `-- name: RestoreAllSaldos :exec
UPDATE saldos
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Saldos
func (q *Queries) RestoreAllSaldos(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllSaldos)
	return err
}

const restoreSaldo = `-- name: RestoreSaldo :exec
UPDATE saldos
SET
    deleted_at = NULL
WHERE
    saldo_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Saldo
func (q *Queries) RestoreSaldo(ctx context.Context, saldoID int32) error {
	_, err := q.db.ExecContext(ctx, restoreSaldo, saldoID)
	return err
}

const trashSaldo = `-- name: TrashSaldo :exec
UPDATE saldos
SET
    deleted_at = current_timestamp
WHERE
    saldo_id = $1
    AND deleted_at IS NULL
`

// Trash Saldo
func (q *Queries) TrashSaldo(ctx context.Context, saldoID int32) error {
	_, err := q.db.ExecContext(ctx, trashSaldo, saldoID)
	return err
}

const updateSaldo = `-- name: UpdateSaldo :exec
UPDATE saldos
SET
    card_number = $2,
    total_balance = $3,
    updated_at = current_timestamp
WHERE
    saldo_id = $1
    AND deleted_at IS NULL
`

type UpdateSaldoParams struct {
	SaldoID      int32  `json:"saldo_id"`
	CardNumber   string `json:"card_number"`
	TotalBalance int32  `json:"total_balance"`
}

// Update Saldo
func (q *Queries) UpdateSaldo(ctx context.Context, arg UpdateSaldoParams) error {
	_, err := q.db.ExecContext(ctx, updateSaldo, arg.SaldoID, arg.CardNumber, arg.TotalBalance)
	return err
}

const updateSaldoBalance = `-- name: UpdateSaldoBalance :exec
UPDATE saldos
SET
    total_balance = $2,
    updated_at = current_timestamp
WHERE
    card_number = $1
    AND deleted_at IS NULL
`

type UpdateSaldoBalanceParams struct {
	CardNumber   string `json:"card_number"`
	TotalBalance int32  `json:"total_balance"`
}

// Update Saldo Balance
func (q *Queries) UpdateSaldoBalance(ctx context.Context, arg UpdateSaldoBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateSaldoBalance, arg.CardNumber, arg.TotalBalance)
	return err
}

const updateSaldoWithdraw = `-- name: UpdateSaldoWithdraw :exec
UPDATE saldos
SET
    withdraw_amount = $2,
    total_balance = total_balance - $2,
    withdraw_time = $3,
    updated_at = current_timestamp
WHERE
    card_number = $1
    AND deleted_at IS NULL
    AND total_balance >= $2
`

type UpdateSaldoWithdrawParams struct {
	CardNumber     string        `json:"card_number"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
}

// Update Saldo Withdraw
func (q *Queries) UpdateSaldoWithdraw(ctx context.Context, arg UpdateSaldoWithdrawParams) error {
	_, err := q.db.ExecContext(ctx, updateSaldoWithdraw, arg.CardNumber, arg.WithdrawAmount, arg.WithdrawTime)
	return err
}
