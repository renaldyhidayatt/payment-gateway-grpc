// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: saldo.sql

package db

import (
	"context"
	"database/sql"
)

const countAllSaldos = `-- name: CountAllSaldos :one
SELECT COUNT(*)
FROM saldos
WHERE deleted_at IS NULL
`

func (q *Queries) CountAllSaldos(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllSaldos)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSaldos = `-- name: CountSaldos :one
SELECT COUNT(*)
FROM saldos
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
`

func (q *Queries) CountSaldos(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSaldos, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSaldo = `-- name: CreateSaldo :one
INSERT INTO
    saldos (
        card_number,
        total_balance,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        current_timestamp,
        current_timestamp
    ) RETURNING saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at
`

type CreateSaldoParams struct {
	CardNumber   string `json:"card_number"`
	TotalBalance int32  `json:"total_balance"`
}

// Create Saldo
func (q *Queries) CreateSaldo(ctx context.Context, arg CreateSaldoParams) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, createSaldo, arg.CardNumber, arg.TotalBalance)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteSaldoPermanently = `-- name: DeleteSaldoPermanently :exec
DELETE FROM saldos WHERE saldo_id = $1
`

// Delete Saldo Permanently
func (q *Queries) DeleteSaldoPermanently(ctx context.Context, saldoID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSaldoPermanently, saldoID)
	return err
}

const getActiveSaldos = `-- name: GetActiveSaldos :many
SELECT
    saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM saldos
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY saldo_id
LIMIT $2 OFFSET $3
`

type GetActiveSaldosParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveSaldosRow struct {
	SaldoID        int32         `json:"saldo_id"`
	CardNumber     string        `json:"card_number"`
	TotalBalance   int32         `json:"total_balance"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	UpdatedAt      sql.NullTime  `json:"updated_at"`
	DeletedAt      sql.NullTime  `json:"deleted_at"`
	TotalCount     int64         `json:"total_count"`
}

// Get All Active Saldos with Pagination, Search, and Total Count
func (q *Queries) GetActiveSaldos(ctx context.Context, arg GetActiveSaldosParams) ([]*GetActiveSaldosRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSaldos, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveSaldosRow
	for rows.Next() {
		var i GetActiveSaldosRow
		if err := rows.Scan(
			&i.SaldoID,
			&i.CardNumber,
			&i.TotalBalance,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalBalance = `-- name: GetMonthlyTotalBalance :many
SELECT
    TO_CHAR(s.created_at, 'Mon') AS month,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
WHERE
    s.deleted_at IS NULL
    AND EXTRACT(YEAR FROM s.created_at) = $1
GROUP BY
    TO_CHAR(s.created_at, 'Mon'),
    EXTRACT(MONTH FROM s.created_at)
ORDER BY
    EXTRACT(MONTH FROM s.created_at)
`

type GetMonthlyTotalBalanceRow struct {
	Month        string `json:"month"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetMonthlyTotalBalance(ctx context.Context, createdAt sql.NullTime) ([]*GetMonthlyTotalBalanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTotalBalance, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTotalBalanceRow
	for rows.Next() {
		var i GetMonthlyTotalBalanceRow
		if err := rows.Scan(&i.Month, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSaldoByCardNumber = `-- name: GetSaldoByCardNumber :one
SELECT saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at FROM saldos WHERE card_number = $1 AND deleted_at IS NULL
`

// Get Saldo by Card Number
func (q *Queries) GetSaldoByCardNumber(ctx context.Context, cardNumber string) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, getSaldoByCardNumber, cardNumber)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSaldoByID = `-- name: GetSaldoByID :one
SELECT saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at FROM saldos WHERE saldo_id = $1 AND deleted_at IS NULL
`

// Get Saldo by ID
func (q *Queries) GetSaldoByID(ctx context.Context, saldoID int32) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, getSaldoByID, saldoID)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSaldos = `-- name: GetSaldos :many
SELECT
    saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM saldos
WHERE deleted_at IS NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY saldo_id
LIMIT $2 OFFSET $3
`

type GetSaldosParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetSaldosRow struct {
	SaldoID        int32         `json:"saldo_id"`
	CardNumber     string        `json:"card_number"`
	TotalBalance   int32         `json:"total_balance"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	UpdatedAt      sql.NullTime  `json:"updated_at"`
	DeletedAt      sql.NullTime  `json:"deleted_at"`
	TotalCount     int64         `json:"total_count"`
}

// Search Saldos with Pagination and Total Count
func (q *Queries) GetSaldos(ctx context.Context, arg GetSaldosParams) ([]*GetSaldosRow, error) {
	rows, err := q.db.QueryContext(ctx, getSaldos, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSaldosRow
	for rows.Next() {
		var i GetSaldosRow
		if err := rows.Scan(
			&i.SaldoID,
			&i.CardNumber,
			&i.TotalBalance,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedSaldoByID = `-- name: GetTrashedSaldoByID :one
SELECT saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at FROM saldos WHERE saldo_id = $1 AND deleted_at IS NOT NULL
`

// Get Trashed By Saldo ID
func (q *Queries) GetTrashedSaldoByID(ctx context.Context, saldoID int32) (*Saldo, error) {
	row := q.db.QueryRowContext(ctx, getTrashedSaldoByID, saldoID)
	var i Saldo
	err := row.Scan(
		&i.SaldoID,
		&i.CardNumber,
		&i.TotalBalance,
		&i.WithdrawAmount,
		&i.WithdrawTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedSaldos = `-- name: GetTrashedSaldos :many
SELECT
    saldo_id, card_number, total_balance, withdraw_amount, withdraw_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM saldos
WHERE deleted_at IS NOT NULL
  AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%')
ORDER BY saldo_id
LIMIT $2 OFFSET $3
`

type GetTrashedSaldosParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedSaldosRow struct {
	SaldoID        int32         `json:"saldo_id"`
	CardNumber     string        `json:"card_number"`
	TotalBalance   int32         `json:"total_balance"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	UpdatedAt      sql.NullTime  `json:"updated_at"`
	DeletedAt      sql.NullTime  `json:"deleted_at"`
	TotalCount     int64         `json:"total_count"`
}

// Get Trashed Saldos with Pagination, Search, and Total Count
func (q *Queries) GetTrashedSaldos(ctx context.Context, arg GetTrashedSaldosParams) ([]*GetTrashedSaldosRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedSaldos, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedSaldosRow
	for rows.Next() {
		var i GetTrashedSaldosRow
		if err := rows.Scan(
			&i.SaldoID,
			&i.CardNumber,
			&i.TotalBalance,
			&i.WithdrawAmount,
			&i.WithdrawTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTotalBalance = `-- name: GetYearlyTotalBalance :many
SELECT
    EXTRACT(YEAR FROM s.created_at) AS year,
    SUM(s.total_balance) AS total_balance
FROM
    saldos s
WHERE
    s.deleted_at IS NULL
GROUP BY
    EXTRACT(YEAR FROM s.created_at)
ORDER BY
    year
`

type GetYearlyTotalBalanceRow struct {
	Year         string `json:"year"`
	TotalBalance int64  `json:"total_balance"`
}

func (q *Queries) GetYearlyTotalBalance(ctx context.Context) ([]*GetYearlyTotalBalanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTotalBalance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTotalBalanceRow
	for rows.Next() {
		var i GetYearlyTotalBalanceRow
		if err := rows.Scan(&i.Year, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreSaldo = `-- name: RestoreSaldo :exec
UPDATE saldos
SET
    deleted_at = NULL
WHERE
    saldo_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Saldo
func (q *Queries) RestoreSaldo(ctx context.Context, saldoID int32) error {
	_, err := q.db.ExecContext(ctx, restoreSaldo, saldoID)
	return err
}

const trashSaldo = `-- name: TrashSaldo :exec
UPDATE saldos
SET
    deleted_at = current_timestamp
WHERE
    saldo_id = $1
    AND deleted_at IS NULL
`

// Trash Saldo
func (q *Queries) TrashSaldo(ctx context.Context, saldoID int32) error {
	_, err := q.db.ExecContext(ctx, trashSaldo, saldoID)
	return err
}

const updateSaldo = `-- name: UpdateSaldo :exec
UPDATE saldos
SET
    card_number = $2,
    total_balance = $3,
    updated_at = current_timestamp
WHERE
    saldo_id = $1
    AND deleted_at IS NULL
`

type UpdateSaldoParams struct {
	SaldoID      int32  `json:"saldo_id"`
	CardNumber   string `json:"card_number"`
	TotalBalance int32  `json:"total_balance"`
}

// Update Saldo
func (q *Queries) UpdateSaldo(ctx context.Context, arg UpdateSaldoParams) error {
	_, err := q.db.ExecContext(ctx, updateSaldo, arg.SaldoID, arg.CardNumber, arg.TotalBalance)
	return err
}

const updateSaldoBalance = `-- name: UpdateSaldoBalance :exec
UPDATE saldos
SET
    total_balance = $2,
    updated_at = current_timestamp
WHERE
    card_number = $1
    AND deleted_at IS NULL
`

type UpdateSaldoBalanceParams struct {
	CardNumber   string `json:"card_number"`
	TotalBalance int32  `json:"total_balance"`
}

// Update Saldo Balance
func (q *Queries) UpdateSaldoBalance(ctx context.Context, arg UpdateSaldoBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateSaldoBalance, arg.CardNumber, arg.TotalBalance)
	return err
}

const updateSaldoWithdraw = `-- name: UpdateSaldoWithdraw :exec
UPDATE saldos
SET
    withdraw_amount = $2,
    total_balance = total_balance - $2,
    withdraw_time = $3,
    updated_at = current_timestamp
WHERE
    card_number = $1
    AND deleted_at IS NULL
    AND total_balance >= $2
`

type UpdateSaldoWithdrawParams struct {
	CardNumber     string        `json:"card_number"`
	WithdrawAmount sql.NullInt32 `json:"withdraw_amount"`
	WithdrawTime   sql.NullTime  `json:"withdraw_time"`
}

// Update Saldo Withdraw
func (q *Queries) UpdateSaldoWithdraw(ctx context.Context, arg UpdateSaldoWithdrawParams) error {
	_, err := q.db.ExecContext(ctx, updateSaldoWithdraw, arg.CardNumber, arg.WithdrawAmount, arg.WithdrawTime)
	return err
}
