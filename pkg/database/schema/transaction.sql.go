// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO
    transactions (
        card_number,
        amount,
        payment_method,
        merchant_id,
        transaction_time,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        current_timestamp,
        current_timestamp
    ) RETURNING transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at
`

type CreateTransactionParams struct {
	CardNumber      string    `json:"card_number"`
	Amount          int32     `json:"amount"`
	PaymentMethod   string    `json:"payment_method"`
	MerchantID      int32     `json:"merchant_id"`
	TransactionTime time.Time `json:"transaction_time"`
}

// Create Transaction
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.CardNumber,
		arg.Amount,
		arg.PaymentMethod,
		arg.MerchantID,
		arg.TransactionTime,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.TransactionNo,
		&i.CardNumber,
		&i.Amount,
		&i.PaymentMethod,
		&i.MerchantID,
		&i.TransactionTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentTransactions = `-- name: DeleteAllPermanentTransactions :exec
DELETE FROM transactions
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Transactions Permanently
func (q *Queries) DeleteAllPermanentTransactions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentTransactions)
	return err
}

const deleteTransactionPermanently = `-- name: DeleteTransactionPermanently :exec
DELETE FROM transactions WHERE transaction_id = $1 AND deleted_at IS NOT NULL
`

// Delete Transaction Permanently
func (q *Queries) DeleteTransactionPermanently(ctx context.Context, transactionID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionPermanently, transactionID)
	return err
}

const getActiveTransactions = `-- name: GetActiveTransactions :many
SELECT
    transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%' OR payment_method ILIKE '%' || $1 || '%')
ORDER BY
    transaction_time DESC
LIMIT $2 OFFSET $3
`

type GetActiveTransactionsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveTransactionsRow struct {
	TransactionID   int32        `json:"transaction_id"`
	TransactionNo   uuid.UUID    `json:"transaction_no"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	TransactionTime time.Time    `json:"transaction_time"`
	Status          string       `json:"status"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// Get Active Transactions with Pagination, Search, and Count
func (q *Queries) GetActiveTransactions(ctx context.Context, arg GetActiveTransactionsParams) ([]*GetActiveTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTransactions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveTransactionsRow
	for rows.Next() {
		var i GetActiveTransactionsRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.TransactionNo,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.TransactionTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTransactionStatusFailed = `-- name: GetMonthTransactionStatusFailed :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        EXTRACT(MONTH FROM t.transaction_time)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            (t.transaction_time >= $1::timestamp AND t.transaction_time <= $2::timestamp)
            OR (t.transaction_time >= $3::timestamp AND t.transaction_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        EXTRACT(MONTH FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTransactionStatusFailedParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTransactionStatusFailedRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthTransactionStatusFailed(ctx context.Context, arg GetMonthTransactionStatusFailedParams) ([]*GetMonthTransactionStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTransactionStatusFailed,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTransactionStatusFailedRow
	for rows.Next() {
		var i GetMonthTransactionStatusFailedRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTransactionStatusSuccess = `-- name: GetMonthTransactionStatusSuccess :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        EXTRACT(MONTH FROM t.transaction_time)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            (t.transaction_time >= $1::timestamp AND t.transaction_time <= $2::timestamp)
            OR (t.transaction_time >= $3::timestamp AND t.transaction_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time),
        EXTRACT(MONTH FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTransactionStatusSuccessParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTransactionStatusSuccessRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetMonthTransactionStatusSuccess(ctx context.Context, arg GetMonthTransactionStatusSuccessParams) ([]*GetMonthTransactionStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTransactionStatusSuccess,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTransactionStatusSuccessRow
	for rows.Next() {
		var i GetMonthTransactionStatusSuccessRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmounts = `-- name: GetMonthlyAmounts :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyAmountsRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyAmounts(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountsRow
	for rows.Next() {
		var i GetMonthlyAmountsRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAmountsByCardNumber = `-- name: GetMonthlyAmountsByCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.card_number = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyAmountsByCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyAmountsByCardNumberRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyAmountsByCardNumber(ctx context.Context, arg GetMonthlyAmountsByCardNumberParams) ([]*GetMonthlyAmountsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyAmountsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyAmountsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyAmountsByCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPaymentMethods = `-- name: GetMonthlyPaymentMethods :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    pm.payment_method,
    COALESCE(COUNT(t.transaction_id), 0)::int AS total_transactions,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    payment_methods pm
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.payment_method = pm.payment_method
    AND t.deleted_at IS NULL
GROUP BY
    m.month,
    pm.payment_method
ORDER BY
    m.month,
    pm.payment_method
`

type GetMonthlyPaymentMethodsRow struct {
	Month             string `json:"month"`
	PaymentMethod     string `json:"payment_method"`
	TotalTransactions int32  `json:"total_transactions"`
	TotalAmount       int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyPaymentMethods(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyPaymentMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyPaymentMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyPaymentMethodsRow
	for rows.Next() {
		var i GetMonthlyPaymentMethodsRow
		if err := rows.Scan(
			&i.Month,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPaymentMethodsByCardNumber = `-- name: GetMonthlyPaymentMethodsByCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
payment_methods AS (
    SELECT DISTINCT payment_method
    FROM transactions
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    pm.payment_method,
    COALESCE(COUNT(t.transaction_id), 0)::int AS total_transactions,
    COALESCE(SUM(t.amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    payment_methods pm
LEFT JOIN
    transactions t ON EXTRACT(MONTH FROM t.transaction_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transaction_time) = EXTRACT(YEAR FROM m.month)
    AND t.payment_method = pm.payment_method
    AND t.card_number = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month,
    pm.payment_method
ORDER BY
    m.month,
    pm.payment_method
`

type GetMonthlyPaymentMethodsByCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyPaymentMethodsByCardNumberRow struct {
	Month             string `json:"month"`
	PaymentMethod     string `json:"payment_method"`
	TotalTransactions int32  `json:"total_transactions"`
	TotalAmount       int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyPaymentMethodsByCardNumber(ctx context.Context, arg GetMonthlyPaymentMethodsByCardNumberParams) ([]*GetMonthlyPaymentMethodsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyPaymentMethodsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyPaymentMethodsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyPaymentMethodsByCardNumberRow
		if err := rows.Scan(
			&i.Month,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByCardNumber = `-- name: GetTransactionByCardNumber :many
SELECT
    transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions
WHERE
    deleted_at IS NULL
    AND card_number = $1
    AND ($2::TEXT IS NULL OR payment_method ILIKE '%' || $2 || '%')
ORDER BY
    transaction_time DESC
LIMIT $3 OFFSET $4
`

type GetTransactionByCardNumberParams struct {
	CardNumber string `json:"card_number"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetTransactionByCardNumberRow struct {
	TransactionID   int32        `json:"transaction_id"`
	TransactionNo   uuid.UUID    `json:"transaction_no"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	TransactionTime time.Time    `json:"transaction_time"`
	Status          string       `json:"status"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

func (q *Queries) GetTransactionByCardNumber(ctx context.Context, arg GetTransactionByCardNumberParams) ([]*GetTransactionByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionByCardNumber,
		arg.CardNumber,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionByCardNumberRow
	for rows.Next() {
		var i GetTransactionByCardNumberRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.TransactionNo,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.TransactionTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at
FROM transactions
WHERE
    transaction_id = $1
    AND deleted_at IS NULL
`

// Get Transaction by ID
func (q *Queries) GetTransactionByID(ctx context.Context, transactionID int32) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.TransactionNo,
		&i.CardNumber,
		&i.Amount,
		&i.PaymentMethod,
		&i.MerchantID,
		&i.TransactionTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT
    transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR payment_method ILIKE '%' || $1 || '%'
        OR status ILIKE '%' || $1 || '%'
    )
ORDER BY
    transaction_time DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransactionsRow struct {
	TransactionID   int32        `json:"transaction_id"`
	TransactionNo   uuid.UUID    `json:"transaction_no"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	TransactionTime time.Time    `json:"transaction_time"`
	Status          string       `json:"status"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// Search Transactions with Pagination
func (q *Queries) GetTransactions(ctx context.Context, arg GetTransactionsParams) ([]*GetTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsRow
	for rows.Next() {
		var i GetTransactionsRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.TransactionNo,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.TransactionTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByCardNumber = `-- name: GetTransactionsByCardNumber :many
SELECT
    transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions
WHERE
    deleted_at IS NULL
    AND card_number = $1
    AND (
        $2::TEXT IS NULL
        OR payment_method ILIKE '%' || $2 || '%'
        OR status ILIKE '%' || $2 || '%'
    )
ORDER BY
    transaction_time DESC
LIMIT $3 OFFSET $4
`

type GetTransactionsByCardNumberParams struct {
	CardNumber string `json:"card_number"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetTransactionsByCardNumberRow struct {
	TransactionID   int32        `json:"transaction_id"`
	TransactionNo   uuid.UUID    `json:"transaction_no"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	TransactionTime time.Time    `json:"transaction_time"`
	Status          string       `json:"status"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// Get Transactions by Card Number
func (q *Queries) GetTransactionsByCardNumber(ctx context.Context, arg GetTransactionsByCardNumberParams) ([]*GetTransactionsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByCardNumber,
		arg.CardNumber,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsByCardNumberRow
	for rows.Next() {
		var i GetTransactionsByCardNumberRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.TransactionNo,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.TransactionTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByMerchantID = `-- name: GetTransactionsByMerchantID :many
SELECT transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at
FROM transactions
WHERE
    merchant_id = $1
    AND deleted_at IS NULL
ORDER BY transaction_time DESC
`

// Get Transactions by Merchant ID
func (q *Queries) GetTransactionsByMerchantID(ctx context.Context, merchantID int32) ([]*Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByMerchantID, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.TransactionNo,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.TransactionTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedTransactionByID = `-- name: GetTrashedTransactionByID :one
SELECT transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at
FROM transactions
WHERE
    transaction_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Transaction ID
func (q *Queries) GetTrashedTransactionByID(ctx context.Context, transactionID int32) (*Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTrashedTransactionByID, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.TransactionNo,
		&i.CardNumber,
		&i.Amount,
		&i.PaymentMethod,
		&i.MerchantID,
		&i.TransactionTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedTransactions = `-- name: GetTrashedTransactions :many
SELECT
    transaction_id, transaction_no, card_number, amount, payment_method, merchant_id, transaction_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transactions
WHERE
    deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR card_number ILIKE '%' || $1 || '%' OR payment_method ILIKE '%' || $1 || '%')
ORDER BY
    transaction_time DESC
LIMIT $2 OFFSET $3
`

type GetTrashedTransactionsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedTransactionsRow struct {
	TransactionID   int32        `json:"transaction_id"`
	TransactionNo   uuid.UUID    `json:"transaction_no"`
	CardNumber      string       `json:"card_number"`
	Amount          int32        `json:"amount"`
	PaymentMethod   string       `json:"payment_method"`
	MerchantID      int32        `json:"merchant_id"`
	TransactionTime time.Time    `json:"transaction_time"`
	Status          string       `json:"status"`
	CreatedAt       sql.NullTime `json:"created_at"`
	UpdatedAt       sql.NullTime `json:"updated_at"`
	DeletedAt       sql.NullTime `json:"deleted_at"`
	TotalCount      int64        `json:"total_count"`
}

// Get Trashed Transactions with Pagination, Search, and Count
func (q *Queries) GetTrashedTransactions(ctx context.Context, arg GetTrashedTransactionsParams) ([]*GetTrashedTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedTransactions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedTransactionsRow
	for rows.Next() {
		var i GetTrashedTransactionsRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.TransactionNo,
			&i.CardNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.MerchantID,
			&i.TransactionTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmounts = `-- name: GetYearlyAmounts :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    SUM(t.amount) AS total_amount
FROM
    transactions t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.created_at) >= $1 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.created_at)
ORDER BY
    year
`

type GetYearlyAmountsRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyAmounts(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountsRow
	for rows.Next() {
		var i GetYearlyAmountsRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyAmountsByCardNumber = `-- name: GetYearlyAmountsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    SUM(t.amount) AS total_amount
FROM
    transactions t
WHERE
    t.deleted_at IS NULL
    AND t.card_number = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.created_at)
ORDER BY
    year
`

type GetYearlyAmountsByCardNumberParams struct {
	CardNumber string      `json:"card_number"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyAmountsByCardNumberRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyAmountsByCardNumber(ctx context.Context, arg GetYearlyAmountsByCardNumberParams) ([]*GetYearlyAmountsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyAmountsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyAmountsByCardNumberRow
	for rows.Next() {
		var i GetYearlyAmountsByCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyPaymentMethods = `-- name: GetYearlyPaymentMethods :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    t.payment_method,
    COUNT(t.transaction_id) AS total_transactions,
    SUM(t.amount) AS total_amount
FROM
    transactions t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.created_at) >= $1 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.created_at),
    t.payment_method
ORDER BY
    year
`

type GetYearlyPaymentMethodsRow struct {
	Year              string `json:"year"`
	PaymentMethod     string `json:"payment_method"`
	TotalTransactions int64  `json:"total_transactions"`
	TotalAmount       int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyPaymentMethods(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyPaymentMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyPaymentMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyPaymentMethodsRow
	for rows.Next() {
		var i GetYearlyPaymentMethodsRow
		if err := rows.Scan(
			&i.Year,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyPaymentMethodsByCardNumber = `-- name: GetYearlyPaymentMethodsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    t.payment_method,
    COUNT(t.transaction_id) AS total_transactions,
    SUM(t.amount) AS total_amount
FROM
    transactions t
WHERE
    t.deleted_at IS NULL
    AND t.card_number = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.created_at),
    t.payment_method
ORDER BY
    year
`

type GetYearlyPaymentMethodsByCardNumberParams struct {
	CardNumber string      `json:"card_number"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyPaymentMethodsByCardNumberRow struct {
	Year              string `json:"year"`
	PaymentMethod     string `json:"payment_method"`
	TotalTransactions int64  `json:"total_transactions"`
	TotalAmount       int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyPaymentMethodsByCardNumber(ctx context.Context, arg GetYearlyPaymentMethodsByCardNumberParams) ([]*GetYearlyPaymentMethodsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyPaymentMethodsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyPaymentMethodsByCardNumberRow
	for rows.Next() {
		var i GetYearlyPaymentMethodsByCardNumberRow
		if err := rows.Scan(
			&i.Year,
			&i.PaymentMethod,
			&i.TotalTransactions,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransactionStatusFailed = `-- name: GetYearlyTransactionStatusFailed :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            EXTRACT(YEAR FROM t.transaction_time) = $1::integer
            OR EXTRACT(YEAR FROM t.transaction_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTransactionStatusFailedRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyTransactionStatusFailed(ctx context.Context, dollar_1 int32) ([]*GetYearlyTransactionStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransactionStatusFailed, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransactionStatusFailedRow
	for rows.Next() {
		var i GetYearlyTransactionStatusFailedRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransactionStatusSuccess = `-- name: GetYearlyTransactionStatusSuccess :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transaction_time)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.amount), 0)::integer AS total_amount
    FROM
        transactions t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            EXTRACT(YEAR FROM t.transaction_time) = $1::integer
            OR EXTRACT(YEAR FROM t.transaction_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transaction_time)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTransactionStatusSuccessRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyTransactionStatusSuccess(ctx context.Context, dollar_1 int32) ([]*GetYearlyTransactionStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransactionStatusSuccess, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransactionStatusSuccessRow
	for rows.Next() {
		var i GetYearlyTransactionStatusSuccessRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllTransactions = `-- name: RestoreAllTransactions :exec
UPDATE transactions
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Transactions
func (q *Queries) RestoreAllTransactions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllTransactions)
	return err
}

const restoreTransaction = `-- name: RestoreTransaction :exec
UPDATE transactions
SET
    deleted_at = NULL
WHERE
    transaction_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Transaction
func (q *Queries) RestoreTransaction(ctx context.Context, transactionID int32) error {
	_, err := q.db.ExecContext(ctx, restoreTransaction, transactionID)
	return err
}

const trashTransaction = `-- name: TrashTransaction :exec
UPDATE transactions
SET
    deleted_at = current_timestamp
WHERE
    transaction_id = $1
    AND deleted_at IS NULL
`

// Trash Transaction
func (q *Queries) TrashTransaction(ctx context.Context, transactionID int32) error {
	_, err := q.db.ExecContext(ctx, trashTransaction, transactionID)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE transactions
SET
    card_number = $2,
    amount = $3,
    payment_method = $4,
    merchant_id = $5,
    transaction_time = $6,
    updated_at = current_timestamp
WHERE
    transaction_id = $1
    AND deleted_at IS NULL
`

type UpdateTransactionParams struct {
	TransactionID   int32     `json:"transaction_id"`
	CardNumber      string    `json:"card_number"`
	Amount          int32     `json:"amount"`
	PaymentMethod   string    `json:"payment_method"`
	MerchantID      int32     `json:"merchant_id"`
	TransactionTime time.Time `json:"transaction_time"`
}

// Update Transaction
func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, updateTransaction,
		arg.TransactionID,
		arg.CardNumber,
		arg.Amount,
		arg.PaymentMethod,
		arg.MerchantID,
		arg.TransactionTime,
	)
	return err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions
SET
    status = $2,
    updated_at = current_timestamp
WHERE
    transaction_id = $1
    AND deleted_at IS NULL
`

type UpdateTransactionStatusParams struct {
	TransactionID int32  `json:"transaction_id"`
	Status        string `json:"status"`
}

// Update Transaction Status
func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionStatus, arg.TransactionID, arg.Status)
	return err
}
