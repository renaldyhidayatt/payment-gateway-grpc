// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transfer.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countAllTransfers = `-- name: CountAllTransfers :one
SELECT COUNT(*) FROM transfers WHERE deleted_at IS NULL
`

// Count All Transfers
func (q *Queries) CountAllTransfers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllTransfers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransfers = `-- name: CountTransfers :one
SELECT COUNT(*)
FROM transfers
WHERE deleted_at IS NULL
    AND ($1::TEXT IS NULL OR
        transfer_from ILIKE '%' || $1 || '%' OR
        transfer_to ILIKE '%' || $1 || '%' OR
        CAST(transfer_time AS TEXT) ILIKE '%' || $1 || '%')
`

func (q *Queries) CountTransfers(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransfers, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransfersByDate = `-- name: CountTransfersByDate :one
SELECT COUNT(*)
FROM transfers
WHERE deleted_at IS NULL
  AND transfer_time::DATE = $1::DATE
`

// Count Transfers by Date
func (q *Queries) CountTransfersByDate(ctx context.Context, dollar_1 time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransfersByDate, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO
    transfers (
        transfer_from,
        transfer_to,
        transfer_amount,
        transfer_time,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        current_timestamp,
        current_timestamp,
        current_timestamp
    ) RETURNING transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
`

type CreateTransferParams struct {
	TransferFrom   string `json:"transfer_from"`
	TransferTo     string `json:"transfer_to"`
	TransferAmount int32  `json:"transfer_amount"`
}

// Create Transfer
func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, createTransfer, arg.TransferFrom, arg.TransferTo, arg.TransferAmount)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteTransferPermanently = `-- name: DeleteTransferPermanently :exec
DELETE FROM transfers WHERE transfer_id = $1
`

// Delete Transfer Permanently
func (q *Queries) DeleteTransferPermanently(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransferPermanently, transferID)
	return err
}

const findAllTransfersByCardNumberAsReceiver = `-- name: FindAllTransfersByCardNumberAsReceiver :many
SELECT
    t.transfer_id,
    t.transfer_from,
    t.transfer_to,
    t.transfer_amount,
    t.transfer_time,
    t.created_at,
    t.updated_at,
    t.deleted_at
FROM
    transfers t
WHERE
    t.transfer_to = $1
    AND t.deleted_at IS NULL
ORDER BY
    t.transfer_time DESC
`

func (q *Queries) FindAllTransfersByCardNumberAsReceiver(ctx context.Context, transferTo string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransfersByCardNumberAsReceiver, transferTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllTransfersByCardNumberAsSender = `-- name: FindAllTransfersByCardNumberAsSender :many
SELECT
    t.transfer_id,
    t.transfer_from,
    t.transfer_to,
    t.transfer_amount,
    t.transfer_time,
    t.created_at,
    t.updated_at,
    t.deleted_at
FROM
    transfers t
WHERE
    t.transfer_from = $1
    AND t.deleted_at IS NULL
ORDER BY
    t.transfer_time DESC
`

func (q *Queries) FindAllTransfersByCardNumberAsSender(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransfersByCardNumberAsSender, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTransfers = `-- name: GetActiveTransfers :many
SELECT
    transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transfers
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY
    transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetActiveTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveTransfersRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Get Active Transfers with Search, Pagination, and Total Count
func (q *Queries) GetActiveTransfers(ctx context.Context, arg GetActiveTransfersParams) ([]*GetActiveTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveTransfersRow
	for rows.Next() {
		var i GetActiveTransfersRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTransferAmounts = `-- name: GetMonthlyTransferAmounts :many
SELECT
    TO_CHAR(t.transfer_time, 'Mon') AS month,
    SUM(t.transfer_amount) AS total_transfer_amount
FROM
    transfers t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.transfer_time) = $1
GROUP BY
    TO_CHAR(t.transfer_time, 'Mon'),
    EXTRACT(MONTH FROM t.transfer_time)
ORDER BY
    EXTRACT(MONTH FROM t.transfer_time)
`

type GetMonthlyTransferAmountsRow struct {
	Month               string `json:"month"`
	TotalTransferAmount int64  `json:"total_transfer_amount"`
}

func (q *Queries) GetMonthlyTransferAmounts(ctx context.Context, transferTime time.Time) ([]*GetMonthlyTransferAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTransferAmounts, transferTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTransferAmountsRow
	for rows.Next() {
		var i GetMonthlyTransferAmountsRow
		if err := rows.Scan(&i.Month, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransferByID = `-- name: GetTransferByID :one
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

// Get Transfer by ID
func (q *Queries) GetTransferByID(ctx context.Context, transferID int32) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, getTransferByID, transferID)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransfers = `-- name: GetTransfers :many
SELECT
    transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transfers
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY
    transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransfersRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Search Transfers with Pagination
func (q *Queries) GetTransfers(ctx context.Context, arg GetTransfersParams) ([]*GetTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransfersRow
	for rows.Next() {
		var i GetTransfersRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersByCardNumber = `-- name: GetTransfersByCardNumber :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND (
        transfer_from = $1
        OR transfer_to = $1
    )
ORDER BY transfer_time DESC
`

// Get Transfers by Card Number (Source or Destination)
func (q *Queries) GetTransfersByCardNumber(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersByCardNumber, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersByDestinationCard = `-- name: GetTransfersByDestinationCard :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND transfer_to = $1
ORDER BY transfer_time DESC
`

// Get Transfers by Destination Card
func (q *Queries) GetTransfersByDestinationCard(ctx context.Context, transferTo string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersByDestinationCard, transferTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersBySourceCard = `-- name: GetTransfersBySourceCard :many
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND transfer_from = $1
ORDER BY transfer_time DESC
`

// Get Transfers by Source Card
func (q *Queries) GetTransfersBySourceCard(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersBySourceCard, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedTransferByID = `-- name: GetTrashedTransferByID :one
SELECT transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at
FROM transfers
WHERE
    transfer_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Transfer ID
func (q *Queries) GetTrashedTransferByID(ctx context.Context, transferID int32) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, getTrashedTransferByID, transferID)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedTransfers = `-- name: GetTrashedTransfers :many
SELECT
    transfer_id, transfer_from, transfer_to, transfer_amount, transfer_time, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transfers
WHERE
    deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY
    transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetTrashedTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedTransfersRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Get Trashed Transfers with Search, Pagination, and Total Count
func (q *Queries) GetTrashedTransfers(ctx context.Context, arg GetTrashedTransfersParams) ([]*GetTrashedTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedTransfersRow
	for rows.Next() {
		var i GetTrashedTransfersRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransferAmounts = `-- name: GetYearlyTransferAmounts :many
SELECT
    EXTRACT(YEAR FROM t.transfer_time) AS year,
    SUM(t.transfer_amount) AS total_transfer_amount
FROM
    transfers t
WHERE
    t.deleted_at IS NULL
GROUP BY
    EXTRACT(YEAR FROM t.transfer_time)
ORDER BY
    year
`

type GetYearlyTransferAmountsRow struct {
	Year                string `json:"year"`
	TotalTransferAmount int64  `json:"total_transfer_amount"`
}

func (q *Queries) GetYearlyTransferAmounts(ctx context.Context) ([]*GetYearlyTransferAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransferAmounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransferAmountsRow
	for rows.Next() {
		var i GetYearlyTransferAmountsRow
		if err := rows.Scan(&i.Year, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreTransfer = `-- name: RestoreTransfer :exec
UPDATE transfers
SET
    deleted_at = NULL
WHERE
    transfer_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Transfer
func (q *Queries) RestoreTransfer(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, restoreTransfer, transferID)
	return err
}

const transfer_CountAll = `-- name: Transfer_CountAll :one
SELECT COUNT(*)
FROM transfers
WHERE deleted_at IS NULL
`

func (q *Queries) Transfer_CountAll(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, transfer_CountAll)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const trashTransfer = `-- name: TrashTransfer :exec
UPDATE transfers
SET
    deleted_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

// Trash Transfer
func (q *Queries) TrashTransfer(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, trashTransfer, transferID)
	return err
}

const updateTransfer = `-- name: UpdateTransfer :exec
UPDATE transfers
SET
    transfer_from = $2,
    transfer_to = $3,
    transfer_amount = $4,
    transfer_time = current_timestamp,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferParams struct {
	TransferID     int32  `json:"transfer_id"`
	TransferFrom   string `json:"transfer_from"`
	TransferTo     string `json:"transfer_to"`
	TransferAmount int32  `json:"transfer_amount"`
}

// Update Transfer
func (q *Queries) UpdateTransfer(ctx context.Context, arg UpdateTransferParams) error {
	_, err := q.db.ExecContext(ctx, updateTransfer,
		arg.TransferID,
		arg.TransferFrom,
		arg.TransferTo,
		arg.TransferAmount,
	)
	return err
}

const updateTransferAmount = `-- name: UpdateTransferAmount :exec
UPDATE transfers
SET
    transfer_amount = $2,
    transfer_time = current_timestamp,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferAmountParams struct {
	TransferID     int32 `json:"transfer_id"`
	TransferAmount int32 `json:"transfer_amount"`
}

// Update Transfer Amount
func (q *Queries) UpdateTransferAmount(ctx context.Context, arg UpdateTransferAmountParams) error {
	_, err := q.db.ExecContext(ctx, updateTransferAmount, arg.TransferID, arg.TransferAmount)
	return err
}
