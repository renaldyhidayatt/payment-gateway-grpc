// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transfer.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO
    transfers (
        transfer_from,
        transfer_to,
        transfer_amount,
        transfer_time,
        status,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        current_timestamp,
        current_timestamp
    ) RETURNING transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at
`

type CreateTransferParams struct {
	TransferFrom   string    `json:"transfer_from"`
	TransferTo     string    `json:"transfer_to"`
	TransferAmount int32     `json:"transfer_amount"`
	TransferTime   time.Time `json:"transfer_time"`
	Status         string    `json:"status"`
}

// Create Transfer
func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, createTransfer,
		arg.TransferFrom,
		arg.TransferTo,
		arg.TransferAmount,
		arg.TransferTime,
		arg.Status,
	)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferNo,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentTransfers = `-- name: DeleteAllPermanentTransfers :exec
DELETE FROM transfers
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Transfers Permanently
func (q *Queries) DeleteAllPermanentTransfers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentTransfers)
	return err
}

const deleteTransferPermanently = `-- name: DeleteTransferPermanently :exec
DELETE FROM transfers WHERE transfer_id = $1 AND deleted_at IS NOT NULL
`

// Delete Transfer Permanently
func (q *Queries) DeleteTransferPermanently(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransferPermanently, transferID)
	return err
}

const findAllTransfersByCardNumberAsReceiver = `-- name: FindAllTransfersByCardNumberAsReceiver :many
SELECT
    t.transfer_id,
    t.transfer_from,
    t.transfer_to,
    t.transfer_amount,
    t.transfer_time,
    t.created_at,
    t.updated_at,
    t.deleted_at
FROM
    transfers t
WHERE
    t.transfer_to = $1
    AND t.deleted_at IS NULL
ORDER BY
    t.transfer_time DESC
`

type FindAllTransfersByCardNumberAsReceiverRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
}

func (q *Queries) FindAllTransfersByCardNumberAsReceiver(ctx context.Context, transferTo string) ([]*FindAllTransfersByCardNumberAsReceiverRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransfersByCardNumberAsReceiver, transferTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAllTransfersByCardNumberAsReceiverRow
	for rows.Next() {
		var i FindAllTransfersByCardNumberAsReceiverRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllTransfersByCardNumberAsSender = `-- name: FindAllTransfersByCardNumberAsSender :many
SELECT
    t.transfer_id,
    t.transfer_from,
    t.transfer_to,
    t.transfer_amount,
    t.transfer_time,
    t.created_at,
    t.updated_at,
    t.deleted_at
FROM
    transfers t
WHERE
    t.transfer_from = $1
    AND t.deleted_at IS NULL
ORDER BY
    t.transfer_time DESC
`

type FindAllTransfersByCardNumberAsSenderRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
}

func (q *Queries) FindAllTransfersByCardNumberAsSender(ctx context.Context, transferFrom string) ([]*FindAllTransfersByCardNumberAsSenderRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllTransfersByCardNumberAsSender, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAllTransfersByCardNumberAsSenderRow
	for rows.Next() {
		var i FindAllTransfersByCardNumberAsSenderRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTransfers = `-- name: GetActiveTransfers :many
SELECT
    transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transfers
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY
    transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetActiveTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveTransfersRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferNo     uuid.UUID    `json:"transfer_no"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	Status         string       `json:"status"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Get Active Transfers with Search, Pagination, and Total Count
func (q *Queries) GetActiveTransfers(ctx context.Context, arg GetActiveTransfersParams) ([]*GetActiveTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveTransfersRow
	for rows.Next() {
		var i GetActiveTransfersRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferNo,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTransferStatusFailed = `-- name: GetMonthTransferStatusFailed :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transfer_time)::integer AS year,
        EXTRACT(MONTH FROM t.transfer_time)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.transfer_amount), 0)::integer AS total_amount
    FROM
        transfers t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            (t.transfer_time >= $1::timestamp AND t.transfer_time <= $2::timestamp)
            OR (t.transfer_time >= $3::timestamp AND t.transfer_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transfer_time),
        EXTRACT(MONTH FROM t.transfer_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTransferStatusFailedParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTransferStatusFailedRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthTransferStatusFailed(ctx context.Context, arg GetMonthTransferStatusFailedParams) ([]*GetMonthTransferStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTransferStatusFailed,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTransferStatusFailedRow
	for rows.Next() {
		var i GetMonthTransferStatusFailedRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTransferStatusSuccess = `-- name: GetMonthTransferStatusSuccess :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transfer_time)::integer AS year,
        EXTRACT(MONTH FROM t.transfer_time)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.transfer_amount), 0)::integer AS total_amount
    FROM
        transfers t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            (t.transfer_time >= $1::timestamp AND t.transfer_time <= $2::timestamp)
            OR (t.transfer_time >= $3::timestamp AND t.transfer_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transfer_time),
        EXTRACT(MONTH FROM t.transfer_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTransferStatusSuccessParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTransferStatusSuccessRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetMonthTransferStatusSuccess(ctx context.Context, arg GetMonthTransferStatusSuccessParams) ([]*GetMonthTransferStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTransferStatusSuccess,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTransferStatusSuccessRow
	for rows.Next() {
		var i GetMonthTransferStatusSuccessRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTransferAmounts = `-- name: GetMonthlyTransferAmounts :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.transfer_amount), 0)::int AS total_transfer_amount
FROM
    months m
LEFT JOIN
    transfers t ON EXTRACT(MONTH FROM t.transfer_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transfer_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTransferAmountsRow struct {
	Month               string `json:"month"`
	TotalTransferAmount int32  `json:"total_transfer_amount"`
}

func (q *Queries) GetMonthlyTransferAmounts(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTransferAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTransferAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTransferAmountsRow
	for rows.Next() {
		var i GetMonthlyTransferAmountsRow
		if err := rows.Scan(&i.Month, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTransferAmountsByReceiverCardNumber = `-- name: GetMonthlyTransferAmountsByReceiverCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.transfer_amount), 0)::int AS total_transfer_amount
FROM
    months m
LEFT JOIN
    transfers t ON EXTRACT(MONTH FROM t.transfer_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transfer_time) = EXTRACT(YEAR FROM m.month)
    AND t.transfer_to = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTransferAmountsByReceiverCardNumberParams struct {
	TransferTo string    `json:"transfer_to"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyTransferAmountsByReceiverCardNumberRow struct {
	Month               string `json:"month"`
	TotalTransferAmount int32  `json:"total_transfer_amount"`
}

func (q *Queries) GetMonthlyTransferAmountsByReceiverCardNumber(ctx context.Context, arg GetMonthlyTransferAmountsByReceiverCardNumberParams) ([]*GetMonthlyTransferAmountsByReceiverCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTransferAmountsByReceiverCardNumber, arg.TransferTo, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTransferAmountsByReceiverCardNumberRow
	for rows.Next() {
		var i GetMonthlyTransferAmountsByReceiverCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTransferAmountsBySenderCardNumber = `-- name: GetMonthlyTransferAmountsBySenderCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.transfer_amount), 0)::int AS total_transfer_amount
FROM
    months m
LEFT JOIN
    transfers t ON EXTRACT(MONTH FROM t.transfer_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.transfer_time) = EXTRACT(YEAR FROM m.month)
    AND t.transfer_from = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTransferAmountsBySenderCardNumberParams struct {
	TransferFrom string    `json:"transfer_from"`
	Column2      time.Time `json:"column_2"`
}

type GetMonthlyTransferAmountsBySenderCardNumberRow struct {
	Month               string `json:"month"`
	TotalTransferAmount int32  `json:"total_transfer_amount"`
}

func (q *Queries) GetMonthlyTransferAmountsBySenderCardNumber(ctx context.Context, arg GetMonthlyTransferAmountsBySenderCardNumberParams) ([]*GetMonthlyTransferAmountsBySenderCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTransferAmountsBySenderCardNumber, arg.TransferFrom, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTransferAmountsBySenderCardNumberRow
	for rows.Next() {
		var i GetMonthlyTransferAmountsBySenderCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransferByID = `-- name: GetTransferByID :one
SELECT transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at
FROM transfers
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

// Get Transfer by ID
func (q *Queries) GetTransferByID(ctx context.Context, transferID int32) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, getTransferByID, transferID)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferNo,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransfers = `-- name: GetTransfers :many
SELECT
    transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transfers
WHERE
    deleted_at IS NULL
    AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY
    transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTransfersRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferNo     uuid.UUID    `json:"transfer_no"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	Status         string       `json:"status"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Search Transfers with Pagination
func (q *Queries) GetTransfers(ctx context.Context, arg GetTransfersParams) ([]*GetTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransfersRow
	for rows.Next() {
		var i GetTransfersRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferNo,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersByCardNumber = `-- name: GetTransfersByCardNumber :many
SELECT transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND (
        transfer_from = $1
        OR transfer_to = $1
    )
ORDER BY transfer_time DESC
`

// Get Transfers by Card Number (Source or Destination)
func (q *Queries) GetTransfersByCardNumber(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersByCardNumber, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferNo,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersByDestinationCard = `-- name: GetTransfersByDestinationCard :many
SELECT transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND transfer_to = $1
ORDER BY transfer_time DESC
`

// Get Transfers by Destination Card
func (q *Queries) GetTransfersByDestinationCard(ctx context.Context, transferTo string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersByDestinationCard, transferTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferNo,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransfersBySourceCard = `-- name: GetTransfersBySourceCard :many
SELECT transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at
FROM transfers
WHERE
    deleted_at IS NULL
    AND transfer_from = $1
ORDER BY transfer_time DESC
`

// Get Transfers by Source Card
func (q *Queries) GetTransfersBySourceCard(ctx context.Context, transferFrom string) ([]*Transfer, error) {
	rows, err := q.db.QueryContext(ctx, getTransfersBySourceCard, transferFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferNo,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedTransferByID = `-- name: GetTrashedTransferByID :one
SELECT transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at
FROM transfers
WHERE
    transfer_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Transfer ID
func (q *Queries) GetTrashedTransferByID(ctx context.Context, transferID int32) (*Transfer, error) {
	row := q.db.QueryRowContext(ctx, getTrashedTransferByID, transferID)
	var i Transfer
	err := row.Scan(
		&i.TransferID,
		&i.TransferNo,
		&i.TransferFrom,
		&i.TransferTo,
		&i.TransferAmount,
		&i.TransferTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedTransfers = `-- name: GetTrashedTransfers :many
SELECT
    transfer_id, transfer_no, transfer_from, transfer_to, transfer_amount, transfer_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    transfers
WHERE
    deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR transfer_from ILIKE '%' || $1 || '%' OR transfer_to ILIKE '%' || $1 || '%')
ORDER BY
    transfer_time DESC
LIMIT $2 OFFSET $3
`

type GetTrashedTransfersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedTransfersRow struct {
	TransferID     int32        `json:"transfer_id"`
	TransferNo     uuid.UUID    `json:"transfer_no"`
	TransferFrom   string       `json:"transfer_from"`
	TransferTo     string       `json:"transfer_to"`
	TransferAmount int32        `json:"transfer_amount"`
	TransferTime   time.Time    `json:"transfer_time"`
	Status         string       `json:"status"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	DeletedAt      sql.NullTime `json:"deleted_at"`
	TotalCount     int64        `json:"total_count"`
}

// Get Trashed Transfers with Search, Pagination, and Total Count
func (q *Queries) GetTrashedTransfers(ctx context.Context, arg GetTrashedTransfersParams) ([]*GetTrashedTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedTransfers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedTransfersRow
	for rows.Next() {
		var i GetTrashedTransfersRow
		if err := rows.Scan(
			&i.TransferID,
			&i.TransferNo,
			&i.TransferFrom,
			&i.TransferTo,
			&i.TransferAmount,
			&i.TransferTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransferAmounts = `-- name: GetYearlyTransferAmounts :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    SUM(t.transfer_amount) AS total_transfer_amount
FROM
    transfers t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.created_at) >= $1 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.created_at)
ORDER BY
    year
`

type GetYearlyTransferAmountsRow struct {
	Year                string `json:"year"`
	TotalTransferAmount int64  `json:"total_transfer_amount"`
}

func (q *Queries) GetYearlyTransferAmounts(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyTransferAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransferAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransferAmountsRow
	for rows.Next() {
		var i GetYearlyTransferAmountsRow
		if err := rows.Scan(&i.Year, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransferAmountsByReceiverCardNumber = `-- name: GetYearlyTransferAmountsByReceiverCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    SUM(t.transfer_amount) AS total_transfer_amount
FROM
    transfers t
WHERE
    t.deleted_at IS NULL
    AND t.transfer_to = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.created_at)
ORDER BY
    year
`

type GetYearlyTransferAmountsByReceiverCardNumberParams struct {
	TransferTo string      `json:"transfer_to"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyTransferAmountsByReceiverCardNumberRow struct {
	Year                string `json:"year"`
	TotalTransferAmount int64  `json:"total_transfer_amount"`
}

func (q *Queries) GetYearlyTransferAmountsByReceiverCardNumber(ctx context.Context, arg GetYearlyTransferAmountsByReceiverCardNumberParams) ([]*GetYearlyTransferAmountsByReceiverCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransferAmountsByReceiverCardNumber, arg.TransferTo, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransferAmountsByReceiverCardNumberRow
	for rows.Next() {
		var i GetYearlyTransferAmountsByReceiverCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransferAmountsBySenderCardNumber = `-- name: GetYearlyTransferAmountsBySenderCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    SUM(t.transfer_amount) AS total_transfer_amount
FROM
    transfers t
WHERE
    t.deleted_at IS NULL
    AND t.transfer_from = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.created_at)
ORDER BY
    year
`

type GetYearlyTransferAmountsBySenderCardNumberParams struct {
	TransferFrom string      `json:"transfer_from"`
	Column2      interface{} `json:"column_2"`
}

type GetYearlyTransferAmountsBySenderCardNumberRow struct {
	Year                string `json:"year"`
	TotalTransferAmount int64  `json:"total_transfer_amount"`
}

func (q *Queries) GetYearlyTransferAmountsBySenderCardNumber(ctx context.Context, arg GetYearlyTransferAmountsBySenderCardNumberParams) ([]*GetYearlyTransferAmountsBySenderCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransferAmountsBySenderCardNumber, arg.TransferFrom, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransferAmountsBySenderCardNumberRow
	for rows.Next() {
		var i GetYearlyTransferAmountsBySenderCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalTransferAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransferStatusFailed = `-- name: GetYearlyTransferStatusFailed :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transfer_time)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.transfer_amount), 0)::integer AS total_amount
    FROM
        transfers t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            EXTRACT(YEAR FROM t.transfer_time) = $1::integer
            OR EXTRACT(YEAR FROM t.transfer_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transfer_time)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTransferStatusFailedRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyTransferStatusFailed(ctx context.Context, dollar_1 int32) ([]*GetYearlyTransferStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransferStatusFailed, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransferStatusFailedRow
	for rows.Next() {
		var i GetYearlyTransferStatusFailedRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTransferStatusSuccess = `-- name: GetYearlyTransferStatusSuccess :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.transfer_time)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.transfer_amount), 0)::integer AS total_amount
    FROM
        transfers t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            EXTRACT(YEAR FROM t.transfer_time) = $1::integer
            OR EXTRACT(YEAR FROM t.transfer_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.transfer_time)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTransferStatusSuccessRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyTransferStatusSuccess(ctx context.Context, dollar_1 int32) ([]*GetYearlyTransferStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTransferStatusSuccess, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTransferStatusSuccessRow
	for rows.Next() {
		var i GetYearlyTransferStatusSuccessRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllTransfers = `-- name: RestoreAllTransfers :exec
UPDATE transfers
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Transfers
func (q *Queries) RestoreAllTransfers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllTransfers)
	return err
}

const restoreTransfer = `-- name: RestoreTransfer :exec
UPDATE transfers
SET
    deleted_at = NULL
WHERE
    transfer_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Transfer
func (q *Queries) RestoreTransfer(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, restoreTransfer, transferID)
	return err
}

const trashTransfer = `-- name: TrashTransfer :exec
UPDATE transfers
SET
    deleted_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

// Trash Transfer
func (q *Queries) TrashTransfer(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, trashTransfer, transferID)
	return err
}

const updateTransfer = `-- name: UpdateTransfer :exec
UPDATE transfers
SET
    transfer_from = $2,
    transfer_to = $3,
    transfer_amount = $4,
    transfer_time = $5,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferParams struct {
	TransferID     int32     `json:"transfer_id"`
	TransferFrom   string    `json:"transfer_from"`
	TransferTo     string    `json:"transfer_to"`
	TransferAmount int32     `json:"transfer_amount"`
	TransferTime   time.Time `json:"transfer_time"`
}

// Update Transfer
func (q *Queries) UpdateTransfer(ctx context.Context, arg UpdateTransferParams) error {
	_, err := q.db.ExecContext(ctx, updateTransfer,
		arg.TransferID,
		arg.TransferFrom,
		arg.TransferTo,
		arg.TransferAmount,
		arg.TransferTime,
	)
	return err
}

const updateTransferAmount = `-- name: UpdateTransferAmount :exec
UPDATE transfers
SET
    transfer_amount = $2,
    transfer_time = current_timestamp,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferAmountParams struct {
	TransferID     int32 `json:"transfer_id"`
	TransferAmount int32 `json:"transfer_amount"`
}

// Update Transfer Amount
func (q *Queries) UpdateTransferAmount(ctx context.Context, arg UpdateTransferAmountParams) error {
	_, err := q.db.ExecContext(ctx, updateTransferAmount, arg.TransferID, arg.TransferAmount)
	return err
}

const updateTransferStatus = `-- name: UpdateTransferStatus :exec
UPDATE transfers
SET
    status = $2,
    updated_at = current_timestamp
WHERE
    transfer_id = $1
    AND deleted_at IS NULL
`

type UpdateTransferStatusParams struct {
	TransferID int32  `json:"transfer_id"`
	Status     string `json:"status"`
}

// Update Transfer Status
func (q *Queries) UpdateTransferStatus(ctx context.Context, arg UpdateTransferStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransferStatus, arg.TransferID, arg.Status)
	return err
}
