// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: topup.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTopup = `-- name: CreateTopup :one
INSERT INTO
    topups (
        card_number,
        topup_amount,
        topup_method,
        topup_time,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        current_timestamp,
        current_timestamp
    ) RETURNING topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
`

type CreateTopupParams struct {
	CardNumber  string    `json:"card_number"`
	TopupAmount int32     `json:"topup_amount"`
	TopupMethod string    `json:"topup_method"`
	TopupTime   time.Time `json:"topup_time"`
}

// Create Topup
func (q *Queries) CreateTopup(ctx context.Context, arg CreateTopupParams) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, createTopup,
		arg.CardNumber,
		arg.TopupAmount,
		arg.TopupMethod,
		arg.TopupTime,
	)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentTopups = `-- name: DeleteAllPermanentTopups :exec
DELETE FROM topups
WHERE
    deleted_at IS NOT NULL
`

// Delete All Trashed Saldos Permanently
func (q *Queries) DeleteAllPermanentTopups(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentTopups)
	return err
}

const deleteTopupPermanently = `-- name: DeleteTopupPermanently :exec
DELETE FROM topups WHERE topup_id = $1
`

// Delete Topup Permanently
func (q *Queries) DeleteTopupPermanently(ctx context.Context, topupID int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopupPermanently, topupID)
	return err
}

const getActiveTopups = `-- name: GetActiveTopups :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR topup_no::TEXT ILIKE '%' || $1 || '%'
        OR topup_method ILIKE '%' || $1 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $2 OFFSET $3
`

type GetActiveTopupsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveTopupsRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Get All Active Topups with Pagination and Search
func (q *Queries) GetActiveTopups(ctx context.Context, arg GetActiveTopupsParams) ([]*GetActiveTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTopups, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveTopupsRow
	for rows.Next() {
		var i GetActiveTopupsRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTopupStatusFailed = `-- name: GetMonthTopupStatusFailed :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        EXTRACT(MONTH FROM t.topup_time)::integer AS month,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            (t.topup_time >= $1::timestamp AND t.topup_time <= $2::timestamp)
            OR (t.topup_time >= $3::timestamp AND t.topup_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time),
        EXTRACT(MONTH FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_failed,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_failed,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTopupStatusFailedParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTopupStatusFailedRow struct {
	Year        string `json:"year"`
	Month       string `json:"month"`
	TotalFailed int64  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthTopupStatusFailed(ctx context.Context, arg GetMonthTopupStatusFailedParams) ([]*GetMonthTopupStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTopupStatusFailed,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTopupStatusFailedRow
	for rows.Next() {
		var i GetMonthTopupStatusFailedRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalFailed,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTopupStatusSuccess = `-- name: GetMonthTopupStatusSuccess :many
WITH monthly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        EXTRACT(MONTH FROM t.topup_time)::integer AS month,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            (t.topup_time >= $1::timestamp AND t.topup_time <= $2::timestamp)
            OR (t.topup_time >= $3::timestamp AND t.topup_time <= $4::timestamp)
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time),
        EXTRACT(MONTH FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        TO_CHAR(TO_DATE(month::text, 'MM'), 'Mon') AS month,
        total_success,
        total_amount
    FROM
        monthly_data

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $1::timestamp)::text AS year,
        TO_CHAR($1::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $1::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $1::timestamp)::integer
    )

    UNION ALL

    SELECT
        EXTRACT(YEAR FROM $3::timestamp)::text AS year,
        TO_CHAR($3::timestamp, 'Mon') AS month,
        0 AS total_success,
        0 AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM monthly_data
        WHERE year = EXTRACT(YEAR FROM $3::timestamp)::integer
        AND month = EXTRACT(MONTH FROM $3::timestamp)::integer
    )
)
SELECT year, month, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC,
    TO_DATE(month, 'Mon') DESC
`

type GetMonthTopupStatusSuccessParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
}

type GetMonthTopupStatusSuccessRow struct {
	Year         string `json:"year"`
	Month        string `json:"month"`
	TotalSuccess int64  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetMonthTopupStatusSuccess(ctx context.Context, arg GetMonthTopupStatusSuccessParams) ([]*GetMonthTopupStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthTopupStatusSuccess,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthTopupStatusSuccessRow
	for rows.Next() {
		var i GetMonthTopupStatusSuccessRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.TotalSuccess,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupAmounts = `-- name: GetMonthlyTopupAmounts :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.topup_time) = EXTRACT(YEAR FROM m.month)
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTopupAmountsRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyTopupAmounts(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTopupAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupAmountsRow
	for rows.Next() {
		var i GetMonthlyTopupAmountsRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupAmountsByCardNumber = `-- name: GetMonthlyTopupAmountsByCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.topup_time) = EXTRACT(YEAR FROM m.month)
    AND t.card_number = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month
ORDER BY
    m.month
`

type GetMonthlyTopupAmountsByCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyTopupAmountsByCardNumberRow struct {
	Month       string `json:"month"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyTopupAmountsByCardNumber(ctx context.Context, arg GetMonthlyTopupAmountsByCardNumberParams) ([]*GetMonthlyTopupAmountsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupAmountsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupAmountsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyTopupAmountsByCardNumberRow
		if err := rows.Scan(&i.Month, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupMethods = `-- name: GetMonthlyTopupMethods :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $1::timestamp),
        date_trunc('year', $1::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
topup_methods AS (
    SELECT DISTINCT topup_method
    FROM topups
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    tm.topup_method,
    COALESCE(COUNT(t.topup_id), 0)::int AS total_topups,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    topup_methods tm
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.created_at) = EXTRACT(YEAR FROM m.month)
    AND t.topup_method = tm.topup_method
    AND t.deleted_at IS NULL
GROUP BY
    m.month,
    tm.topup_method
ORDER BY
    m.month,
    tm.topup_method
`

type GetMonthlyTopupMethodsRow struct {
	Month       string `json:"month"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int32  `json:"total_topups"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyTopupMethods(ctx context.Context, dollar_1 time.Time) ([]*GetMonthlyTopupMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupMethodsRow
	for rows.Next() {
		var i GetMonthlyTopupMethodsRow
		if err := rows.Scan(
			&i.Month,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTopupMethodsByCardNumber = `-- name: GetMonthlyTopupMethodsByCardNumber :many
WITH months AS (
    SELECT generate_series(
        date_trunc('year', $2::timestamp),
        date_trunc('year', $2::timestamp) + interval '1 year' - interval '1 day',
        interval '1 month'
    ) AS month
),
topup_methods AS (
    SELECT DISTINCT topup_method
    FROM topups
    WHERE deleted_at IS NULL
)
SELECT
    TO_CHAR(m.month, 'Mon') AS month,
    tm.topup_method,
    COALESCE(COUNT(t.topup_id), 0)::int AS total_topups,
    COALESCE(SUM(t.topup_amount), 0)::int AS total_amount
FROM
    months m
CROSS JOIN
    topup_methods tm
LEFT JOIN
    topups t ON EXTRACT(MONTH FROM t.topup_time) = EXTRACT(MONTH FROM m.month)
    AND EXTRACT(YEAR FROM t.topup_time) = EXTRACT(YEAR FROM m.month)
    AND t.topup_method = tm.topup_method
    AND t.card_number = $1
    AND t.deleted_at IS NULL
GROUP BY
    m.month,
    tm.topup_method
ORDER BY
    m.month,
    tm.topup_method
`

type GetMonthlyTopupMethodsByCardNumberParams struct {
	CardNumber string    `json:"card_number"`
	Column2    time.Time `json:"column_2"`
}

type GetMonthlyTopupMethodsByCardNumberRow struct {
	Month       string `json:"month"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int32  `json:"total_topups"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetMonthlyTopupMethodsByCardNumber(ctx context.Context, arg GetMonthlyTopupMethodsByCardNumberParams) ([]*GetMonthlyTopupMethodsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyTopupMethodsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMonthlyTopupMethodsByCardNumberRow
	for rows.Next() {
		var i GetMonthlyTopupMethodsByCardNumberRow
		if err := rows.Scan(
			&i.Month,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopupByID = `-- name: GetTopupByID :one
SELECT topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at FROM topups WHERE topup_id = $1 AND deleted_at IS NULL
`

// Get Topup by ID
func (q *Queries) GetTopupByID(ctx context.Context, topupID int32) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, getTopupByID, topupID)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTopups = `-- name: GetTopups :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR topup_no::TEXT ILIKE '%' || $1 || '%'
        OR topup_method ILIKE '%' || $1 || '%'
        OR status ILIKE '%' || $1 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $2 OFFSET $3
`

type GetTopupsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTopupsRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Search Topups with Pagination
func (q *Queries) GetTopups(ctx context.Context, arg GetTopupsParams) ([]*GetTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopups, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopupsRow
	for rows.Next() {
		var i GetTopupsRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopupsByCardNumber = `-- name: GetTopupsByCardNumber :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NULL
    AND card_number = $1 -- Filter by card_number
    AND (
        $2::TEXT IS NULL
        OR topup_no::TEXT ILIKE '%' || $2 || '%'
        OR topup_method ILIKE '%' || $2 || '%'
        OR status ILIKE '%' || $2 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $3 OFFSET $4
`

type GetTopupsByCardNumberParams struct {
	CardNumber string `json:"card_number"`
	Column2    string `json:"column_2"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetTopupsByCardNumberRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Get Topups by Card Number
func (q *Queries) GetTopupsByCardNumber(ctx context.Context, arg GetTopupsByCardNumberParams) ([]*GetTopupsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopupsByCardNumber,
		arg.CardNumber,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopupsByCardNumberRow
	for rows.Next() {
		var i GetTopupsByCardNumberRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedTopupByID = `-- name: GetTrashedTopupByID :one
SELECT topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at
FROM topups
WHERE
    topup_id = $1
    AND deleted_at IS NOT NULL
`

// Get Trashed By Topup ID
func (q *Queries) GetTrashedTopupByID(ctx context.Context, topupID int32) (*Topup, error) {
	row := q.db.QueryRowContext(ctx, getTrashedTopupByID, topupID)
	var i Topup
	err := row.Scan(
		&i.TopupID,
		&i.TopupNo,
		&i.CardNumber,
		&i.TopupAmount,
		&i.TopupMethod,
		&i.TopupTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTrashedTopups = `-- name: GetTrashedTopups :many
SELECT
    topup_id, topup_no, card_number, topup_amount, topup_method, topup_time, status, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM
    topups
WHERE
    deleted_at IS NOT NULL
    AND (
        $1::TEXT IS NULL
        OR card_number ILIKE '%' || $1 || '%'
        OR topup_no::TEXT ILIKE '%' || $1 || '%'
        OR topup_method ILIKE '%' || $1 || '%'
    )
ORDER BY
    topup_time DESC
LIMIT $2 OFFSET $3
`

type GetTrashedTopupsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedTopupsRow struct {
	TopupID     int32        `json:"topup_id"`
	TopupNo     uuid.UUID    `json:"topup_no"`
	CardNumber  string       `json:"card_number"`
	TopupAmount int32        `json:"topup_amount"`
	TopupMethod string       `json:"topup_method"`
	TopupTime   time.Time    `json:"topup_time"`
	Status      string       `json:"status"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	TotalCount  int64        `json:"total_count"`
}

// Get Trashed Topups with Pagination and Search
func (q *Queries) GetTrashedTopups(ctx context.Context, arg GetTrashedTopupsParams) ([]*GetTrashedTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedTopups, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedTopupsRow
	for rows.Next() {
		var i GetTrashedTopupsRow
		if err := rows.Scan(
			&i.TopupID,
			&i.TopupNo,
			&i.CardNumber,
			&i.TopupAmount,
			&i.TopupMethod,
			&i.TopupTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupAmounts = `-- name: GetYearlyTopupAmounts :many
SELECT
    EXTRACT(YEAR FROM t.topup_time) AS year,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.topup_time) >= $1 - 4
    AND EXTRACT(YEAR FROM t.topup_time) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.topup_time)
ORDER BY
    year
`

type GetYearlyTopupAmountsRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyTopupAmounts(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyTopupAmountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupAmounts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupAmountsRow
	for rows.Next() {
		var i GetYearlyTopupAmountsRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupAmountsByCardNumber = `-- name: GetYearlyTopupAmountsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.topup_time) AS year,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND t.card_number = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.topup_time)
ORDER BY
    year
`

type GetYearlyTopupAmountsByCardNumberParams struct {
	CardNumber string      `json:"card_number"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyTopupAmountsByCardNumberRow struct {
	Year        string `json:"year"`
	TotalAmount int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyTopupAmountsByCardNumber(ctx context.Context, arg GetYearlyTopupAmountsByCardNumberParams) ([]*GetYearlyTopupAmountsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupAmountsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupAmountsByCardNumberRow
	for rows.Next() {
		var i GetYearlyTopupAmountsByCardNumberRow
		if err := rows.Scan(&i.Year, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupMethods = `-- name: GetYearlyTopupMethods :many
SELECT
    EXTRACT(YEAR FROM t.created_at) AS year,
    t.topup_method,
    COUNT(t.topup_id) AS total_topups,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.topup_time) >= $1 - 4
    AND EXTRACT(YEAR FROM t.topup_time) <= $1
GROUP BY
    EXTRACT(YEAR FROM t.created_at),
    t.topup_method
ORDER BY
    year
`

type GetYearlyTopupMethodsRow struct {
	Year        string `json:"year"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int64  `json:"total_topups"`
	TotalAmount int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyTopupMethods(ctx context.Context, dollar_1 interface{}) ([]*GetYearlyTopupMethodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupMethods, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupMethodsRow
	for rows.Next() {
		var i GetYearlyTopupMethodsRow
		if err := rows.Scan(
			&i.Year,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupMethodsByCardNumber = `-- name: GetYearlyTopupMethodsByCardNumber :many
SELECT
    EXTRACT(YEAR FROM t.topup_time) AS year,
    t.topup_method,
    COUNT(t.topup_id) AS total_topups,
    SUM(t.topup_amount) AS total_amount
FROM
    topups t
WHERE
    t.deleted_at IS NULL
    AND t.card_number = $1
    AND EXTRACT(YEAR FROM t.created_at) >= $2 - 4
    AND EXTRACT(YEAR FROM t.created_at) <= $2
GROUP BY
    EXTRACT(YEAR FROM t.topup_time),
    t.topup_method
ORDER BY
    year
`

type GetYearlyTopupMethodsByCardNumberParams struct {
	CardNumber string      `json:"card_number"`
	Column2    interface{} `json:"column_2"`
}

type GetYearlyTopupMethodsByCardNumberRow struct {
	Year        string `json:"year"`
	TopupMethod string `json:"topup_method"`
	TotalTopups int64  `json:"total_topups"`
	TotalAmount int64  `json:"total_amount"`
}

func (q *Queries) GetYearlyTopupMethodsByCardNumber(ctx context.Context, arg GetYearlyTopupMethodsByCardNumberParams) ([]*GetYearlyTopupMethodsByCardNumberRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupMethodsByCardNumber, arg.CardNumber, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupMethodsByCardNumberRow
	for rows.Next() {
		var i GetYearlyTopupMethodsByCardNumberRow
		if err := rows.Scan(
			&i.Year,
			&i.TopupMethod,
			&i.TotalTopups,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupStatusFailed = `-- name: GetYearlyTopupStatusFailed :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        COUNT(*) AS total_failed,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'failed'
        AND (
            EXTRACT(YEAR FROM t.topup_time) = $1::integer
            OR EXTRACT(YEAR FROM t.topup_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        total_failed::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_failed,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_failed, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTopupStatusFailedRow struct {
	Year        string `json:"year"`
	TotalFailed int32  `json:"total_failed"`
	TotalAmount int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyTopupStatusFailed(ctx context.Context, dollar_1 int32) ([]*GetYearlyTopupStatusFailedRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupStatusFailed, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupStatusFailedRow
	for rows.Next() {
		var i GetYearlyTopupStatusFailedRow
		if err := rows.Scan(&i.Year, &i.TotalFailed, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyTopupStatusSuccess = `-- name: GetYearlyTopupStatusSuccess :many
WITH yearly_data AS (
    SELECT
        EXTRACT(YEAR FROM t.topup_time)::integer AS year,
        COUNT(*) AS total_success,
        COALESCE(SUM(t.topup_amount), 0)::integer AS total_amount
    FROM
        topups t
    WHERE
        t.deleted_at IS NULL
        AND t.status = 'success'
        AND (
            EXTRACT(YEAR FROM t.topup_time) = $1::integer
            OR EXTRACT(YEAR FROM t.topup_time) = $1::integer - 1
        )
    GROUP BY
        EXTRACT(YEAR FROM t.topup_time)
), formatted_data AS (
    SELECT
        year::text,
        total_success::integer,
        total_amount::integer
    FROM
        yearly_data

    UNION ALL

    SELECT
        $1::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer
    )

    UNION ALL

    SELECT
        ($1::integer - 1)::text AS year,
        0::integer AS total_success,
        0::integer AS total_amount
    WHERE NOT EXISTS (
        SELECT 1
        FROM yearly_data
        WHERE year = $1::integer - 1
    )
)
SELECT year, total_success, total_amount FROM formatted_data
ORDER BY
    year DESC
`

type GetYearlyTopupStatusSuccessRow struct {
	Year         string `json:"year"`
	TotalSuccess int32  `json:"total_success"`
	TotalAmount  int32  `json:"total_amount"`
}

func (q *Queries) GetYearlyTopupStatusSuccess(ctx context.Context, dollar_1 int32) ([]*GetYearlyTopupStatusSuccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getYearlyTopupStatusSuccess, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetYearlyTopupStatusSuccessRow
	for rows.Next() {
		var i GetYearlyTopupStatusSuccessRow
		if err := rows.Scan(&i.Year, &i.TotalSuccess, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllTopups = `-- name: RestoreAllTopups :exec
UPDATE topups
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// Restore All Trashed Saldos
func (q *Queries) RestoreAllTopups(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllTopups)
	return err
}

const restoreTopup = `-- name: RestoreTopup :exec
UPDATE topups
SET
    deleted_at = NULL
WHERE
    topup_id = $1
    AND deleted_at IS NOT NULL
`

// Restore Trashed Topup
func (q *Queries) RestoreTopup(ctx context.Context, topupID int32) error {
	_, err := q.db.ExecContext(ctx, restoreTopup, topupID)
	return err
}

const trashTopup = `-- name: TrashTopup :exec
UPDATE topups
SET
    deleted_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
`

// Trash Topup
func (q *Queries) TrashTopup(ctx context.Context, topupID int32) error {
	_, err := q.db.ExecContext(ctx, trashTopup, topupID)
	return err
}

const updateTopup = `-- name: UpdateTopup :exec
UPDATE topups
SET
    card_number = $2,
    topup_amount = $3,
    topup_method = $4,
    topup_time = $5,
    updated_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
`

type UpdateTopupParams struct {
	TopupID     int32     `json:"topup_id"`
	CardNumber  string    `json:"card_number"`
	TopupAmount int32     `json:"topup_amount"`
	TopupMethod string    `json:"topup_method"`
	TopupTime   time.Time `json:"topup_time"`
}

// Update Topup
func (q *Queries) UpdateTopup(ctx context.Context, arg UpdateTopupParams) error {
	_, err := q.db.ExecContext(ctx, updateTopup,
		arg.TopupID,
		arg.CardNumber,
		arg.TopupAmount,
		arg.TopupMethod,
		arg.TopupTime,
	)
	return err
}

const updateTopupAmount = `-- name: UpdateTopupAmount :exec
UPDATE topups
SET
    topup_amount = $2,
    updated_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
`

type UpdateTopupAmountParams struct {
	TopupID     int32 `json:"topup_id"`
	TopupAmount int32 `json:"topup_amount"`
}

// Update Topup Amount
func (q *Queries) UpdateTopupAmount(ctx context.Context, arg UpdateTopupAmountParams) error {
	_, err := q.db.ExecContext(ctx, updateTopupAmount, arg.TopupID, arg.TopupAmount)
	return err
}

const updateTopupStatus = `-- name: UpdateTopupStatus :exec
UPDATE topups
SET
    status = $2,
    updated_at = current_timestamp
WHERE
    topup_id = $1
    AND deleted_at IS NULL
`

type UpdateTopupStatusParams struct {
	TopupID int32  `json:"topup_id"`
	Status  string `json:"status"`
}

// Update Topup Status
func (q *Queries) UpdateTopupStatus(ctx context.Context, arg UpdateTopupStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTopupStatus, arg.TopupID, arg.Status)
	return err
}
